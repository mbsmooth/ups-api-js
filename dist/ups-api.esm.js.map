{"version":3,"file":"ups-api.esm.js","sources":["../node_modules/yonius/dist/yonius.esm.js","../js/locator.js","../js/paperless.js","../js/pickup.js","../js/shipment.js","../js/tracking.js","../js/base.js"],"sourcesContent":["/**\n * Yonius 0.11.7.\n *\n * Copyright (c) 2008-2022 Hive Solutions Lda.\n *\n * This source code is licensed under the Apache 2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as fs from 'fs';\nimport { join, normalize, resolve, dirname } from 'path';\nimport { env } from 'process';\nimport fetch from 'node-fetch';\n\nvar name = \"yonius\";\nvar version = \"0.11.7\";\n\nclass Observable {\r\n    constructor() {\r\n        this.callbacks = {};\r\n    }\r\n\r\n    bind(event, callback) {\r\n        const callbacks = this.callbacks[event] || [];\r\n        callbacks.push(callback);\r\n        this.callbacks[event] = callbacks;\r\n        return callback;\r\n    }\r\n\r\n    unbind(event, callback) {\r\n        const callbacks = this.callbacks[event] || [];\r\n        if (!callback) {\r\n            delete this.callbacks[event];\r\n            return;\r\n        }\r\n\r\n        const index = callbacks.indexOf(callback);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        callbacks.splice(index, 1);\r\n        this.callbacks[event] = callbacks;\r\n    }\r\n\r\n    trigger(event) {\r\n        const callbacks = this.callbacks[event] || [];\r\n        const results = [];\r\n        for (const callback of callbacks) {\r\n            const result = callback.apply(this, Array.prototype.slice.call(arguments, 1));\r\n            result !== undefined && result !== null && results.push(result);\r\n        }\r\n        return Promise.all(results);\r\n    }\r\n}\n\nconst verify = function(\r\n    condition,\r\n    message = null,\r\n    code = null,\r\n    exception = null,\r\n    kwargs = {},\r\n    safeKeys = [\"message\"]\r\n) {\r\n    if (condition) return;\r\n    message = message || \"Verification failed\";\r\n    const Exception = exception || Error;\r\n    kwargs = Object.assign({}, kwargs);\r\n    if (message !== null && message !== undefined) kwargs.message = message;\r\n    if (code !== null && message !== undefined) kwargs.code = code;\r\n    const throwable = new Exception(kwargs.message || undefined);\r\n    throwable.kwargs = kwargs;\r\n    for (const [key, value] of Object.entries(kwargs)) {\r\n        if (safeKeys.includes(key) && throwable[key] !== undefined) {\r\n            continue;\r\n        }\r\n        throwable[key] = value;\r\n    }\r\n    throw throwable;\r\n};\r\n\r\nconst verifyEqual = function(\r\n    first,\r\n    second,\r\n    message = null,\r\n    code = null,\r\n    exception = null,\r\n    kwargs = {}\r\n) {\r\n    message = message || `Expected ${first} got ${second}`;\r\n    return this.verify(first === second, message, code, exception, kwargs);\r\n};\r\n\r\nconst verifyNotEqual = function(\r\n    first,\r\n    second,\r\n    message = null,\r\n    code = null,\r\n    exception = null,\r\n    kwargs = {}\r\n) {\r\n    message = message || `Expected ${first} not equal to ${second}`;\r\n    return this.verify(first !== second, message, code, exception, kwargs);\r\n};\r\n\r\nconst verifyMany = function(\r\n    sequence,\r\n    message = null,\r\n    code = null,\r\n    exception = null,\r\n    kwargs = {}\r\n) {\r\n    sequence.forEach(element => {\r\n        verify(element, message, code, exception, kwargs);\r\n    });\r\n};\n\nlet HOME_DIR = null;\r\n\r\nconst pathExists = async function(path) {\r\n    try {\r\n        await fs.promises.access(path);\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\n\r\nconst expandUser = function(path) {\r\n    if (!path) return path;\r\n    if (path === \"~\") return _homeDir();\r\n    if (path.slice(0, 2) !== \"~/\") return path;\r\n    return join(HOME_DIR, path.slice(2));\r\n};\r\n\r\nconst getEnv = function(name) {\r\n    // eslint-disable-next-line no-undef\r\n    if (typeof Deno !== \"undefined\") return Deno.env.get(name);\r\n    return env[name];\r\n};\r\n\r\nconst getEnvObject = function() {\r\n    // eslint-disable-next-line no-undef\r\n    if (typeof Deno !== \"undefined\") return Deno.env.toObject();\r\n    return env;\r\n};\r\n\r\nconst _homeDir = function() {\r\n    if (HOME_DIR !== null) return HOME_DIR;\r\n    const isWindows = Boolean(typeof process !== \"undefined\" && process.platform === \"win32\");\r\n    HOME_DIR = getEnv(isWindows ? \"USERPROFILE\" : \"HOME\") || \"/\";\r\n    return HOME_DIR;\r\n};\n\nconst FILE_NAME = \"yonius.json\";\r\n\r\nconst HOME_FILE = \"~/.home\";\r\n\r\nconst IMPORT_NAMES = [\"$import\", \"$include\", \"$IMPORT\", \"$INCLUDE\"];\r\n\r\nconst CASTS = {\r\n    int: v => (typeof v === \"number\" ? v : parseInt(v)),\r\n    float: v => (typeof v === \"number\" ? v : parseFloat(v)),\r\n    bool: v => (typeof v === \"boolean\" ? v : [\"1\", \"true\", \"True\"].includes(v)),\r\n    list: v => (Array.isArray(v) ? v : v.split(\";\")),\r\n    tuple: v => (Array.isArray(v) ? v : v.split(\";\"))\r\n};\r\n\r\nconst globals =\r\n    typeof global === \"undefined\"\r\n        ? typeof window === \"undefined\"\r\n            ? typeof self === \"undefined\"\r\n                ? {}\r\n                : self\r\n            : window\r\n        : global;\r\n\r\nglobals.CONFIGS = globals.CONFIGS === undefined ? {} : globals.CONFIGS;\r\n\r\nglobals.CONFIG_F = globals.CONFIG_F === undefined ? [] : globals.CONFIG_F;\r\n\r\nglobals.HOMES = globals.HOMES === undefined ? [] : globals.HOMES;\r\n\r\nglobals.LOADED = globals.LOADED === undefined ? false : globals.LOADED;\r\n\r\nconst conf = function(name, fallback = undefined, cast = null, ctx = null) {\r\n    const configs = ctx ? ctx.configs : globals.CONFIGS;\r\n    cast = _castR(cast);\r\n    let value = configs[name] === undefined ? fallback : configs[name];\r\n    if (cast && value !== undefined && value !== null) value = cast(value);\r\n    return value;\r\n};\r\n\r\nconst confP = async function(name, fallback = undefined, cast = null, ctx = null) {\r\n    await load$1();\r\n    return conf(name, fallback, cast, ctx);\r\n};\r\n\r\nconst confS = function(name, value, ctx = null) {\r\n    const configs = ctx ? ctx.configs : globals.CONFIGS;\r\n    configs[name] = value;\r\n};\r\n\r\nconst load$1 = async function(\r\n    names = [FILE_NAME],\r\n    path = null,\r\n    encoding = \"utf-8\",\r\n    force = false,\r\n    ctx = null\r\n) {\r\n    if (globals.LOADED && !force) return;\r\n    let paths = [];\r\n    const homes = await getHomes();\r\n    for (const home of homes) {\r\n        paths = paths.concat([join(home), join(home, \".config\")]);\r\n    }\r\n    paths.push(path);\r\n    for (const path of paths) {\r\n        for (const name of names) {\r\n            await loadFile(name, path, encoding, ctx);\r\n        }\r\n    }\r\n    await loadEnv(ctx);\r\n    globals.LOADED = true;\r\n};\r\n\r\nconst loadFile = async function(\r\n    name = FILE_NAME,\r\n    path = null,\r\n    encoding = \"utf-8\",\r\n    ctx = null\r\n) {\r\n    const configs = ctx ? ctx.configs : globals.CONFIGS;\r\n    const configF = ctx ? ctx.configF : globals.CONFIG_F;\r\n\r\n    let key;\r\n    let value;\r\n    let exists;\r\n    let filePath;\r\n\r\n    if (path) path = normalize(path);\r\n    if (path) filePath = join(path, name);\r\n    else filePath = name;\r\n\r\n    filePath = resolve(filePath);\r\n    filePath = normalize(filePath);\r\n    const basePath = dirname(filePath);\r\n\r\n    exists = await pathExists(filePath);\r\n    if (!exists) return;\r\n\r\n    exists = configF.includes(filePath);\r\n    if (exists) configF.splice(configF.indexOf(filePath), 1);\r\n    configF.push(filePath);\r\n\r\n    const data = await fs.promises.readFile(filePath, { encoding: encoding });\r\n    const dataJ = JSON.parse(data);\r\n\r\n    await _loadIncludes(basePath, dataJ, encoding);\r\n\r\n    for ([key, value] of Object.entries(dataJ)) {\r\n        if (!_isValid(key)) continue;\r\n        configs[key] = value;\r\n    }\r\n};\r\n\r\nconst loadEnv = async function(ctx = null) {\r\n    const env = getEnvObject();\r\n    const configs = ctx ? ctx.configs : globals.CONFIGS;\r\n    if (env === undefined || env === null) return;\r\n    Object.entries(env).forEach(function([key, value]) {\r\n        configs[key] = value;\r\n    });\r\n};\r\n\r\nconst getHomes = async function(\r\n    filePath = HOME_FILE,\r\n    fallback = \"~\",\r\n    encoding = \"utf-8\",\r\n    forceDefault = false\r\n) {\r\n    if (globals.HOMES.length > 0) return globals.HOMES;\r\n\r\n    const env = getEnvObject();\r\n\r\n    globals.HOMES = env.HOMES === undefined ? null : env.HOMES;\r\n    globals.HOMES = globals.HOMES ? globals.HOMES.split(\";\") : globals.HOMES;\r\n    if (globals.HOMES !== null) return globals.HOMES;\r\n\r\n    fallback = expandUser(fallback);\r\n    fallback = normalize(fallback);\r\n    globals.HOMES = [fallback];\r\n\r\n    filePath = expandUser(filePath);\r\n    filePath = normalize(filePath);\r\n    const exists = await pathExists(filePath);\r\n    if (!exists) return globals.HOMES;\r\n\r\n    if (!forceDefault) globals.HOMES.splice(0, globals.HOMES.length);\r\n\r\n    let data = await fs.promises.readFile(filePath, { encoding: encoding });\r\n    data = data.trim();\r\n\r\n    let paths = data.split(/\\r?\\n/);\r\n    paths = paths.map(v => v.trim());\r\n\r\n    for (let path of paths) {\r\n        path = path.trim();\r\n        if (!path) continue;\r\n        path = expandUser(path);\r\n        path = normalize(path);\r\n        globals.HOMES.push(path);\r\n    }\r\n\r\n    return globals.HOMES;\r\n};\r\n\r\nconst _castR = function(cast) {\r\n    return CASTS[cast] === undefined ? cast : CASTS[cast];\r\n};\r\n\r\nconst _loadIncludes = async function(basePath, config, encoding = \"utf-8\") {\r\n    let includes = [];\r\n\r\n    for (const alias of IMPORT_NAMES) {\r\n        includes = config[alias] === undefined ? includes : config[alias];\r\n    }\r\n\r\n    if (typeof includes === \"string\") {\r\n        includes = includes.split(\";\");\r\n    }\r\n\r\n    for (const include of includes) {\r\n        await loadFile(include, basePath, encoding);\r\n    }\r\n};\r\n\r\nconst _isValid = function(key) {\r\n    if (IMPORT_NAMES.includes(key)) return false;\r\n    return true;\r\n};\r\n\r\nconst _isDevel = function() {\r\n    return [\"DEBUG\"].includes(conf(\"LEVEL\", \"INFO\"));\r\n};\r\n\r\nconst _isSecure = function() {\r\n    return conf(\"SECURE\", true, \"bool\");\r\n};\n\n/**\r\n * The map containing the various attribute alias between the normalized\r\n * manned and the Yonius manner.\r\n */\r\nconst ALIAS = {\r\n    context: \"find_d\",\r\n    filters: \"find_d\",\r\n    \"filters[]\": \"find_d\",\r\n    filter_def: \"find_d\",\r\n    filter_string: \"find_s\",\r\n    filter_name: \"find_n\",\r\n    filter_operator: \"find_o\",\r\n    insensitive: \"find_i\",\r\n    order: \"sort\",\r\n    offset: \"skip\",\r\n    start_record: \"skip\",\r\n    number_records: \"limit\"\r\n};\r\n\r\n/**\r\n * The map associating the various find fields with their respective\r\n * types, note that in case a special conversion operation is required\r\n * the associated value may represent a conversion function instead.\r\n */\r\nconst FIND_TYPES = {\r\n    skip: v => parseInt(v),\r\n    limit: v => Math.max(0, parseInt(v)),\r\n    find_s: v => v,\r\n    find_d: v => (Array.isArray(v) ? v : [v]),\r\n    find_i: v => Boolean(v),\r\n    find_t: v => v,\r\n    find_n: v => v,\r\n    find_o: v => v,\r\n    sort: v => _toSort(v),\r\n    meta: v => Boolean(v),\r\n    fields: v => v\r\n};\r\n\r\n/**\r\n * The map that defines the various default values for a series of\r\n * find related attributes.\r\n */\r\nconst FIND_DEFAULTS = { limit: 10 };\r\n\r\n/**\r\n * The map associating the normalized (text) way of representing sorting\r\n * with the current infra-structure number way of representing the same\r\n * information.\r\n */\r\nconst SORT_MAP = {\r\n    1: 1,\r\n    \"-1\": -1,\r\n    ascending: 1,\r\n    descending: -1\r\n};\r\n\r\nconst getObject = function(params = {}, options = {}) {\r\n    const { alias = false, page = false, find = false, norm = true } = options;\r\n    let result = params;\r\n\r\n    // in case the alias flag is set tries to resolve the attribute alias and\r\n    // in case the find types are set converts the find based attributes using\r\n    // the currently defined mapping map\r\n    if (alias) result = _resolveAlias(result);\r\n    if (page) result = _pageTypes(result);\r\n    if (find) {\r\n        result = _findTypes(result);\r\n        result = _findDefaults(result, options);\r\n    }\r\n\r\n    // in case the normalization flag is set runs the normalization of the\r\n    // provided object so that sequences are properly handled as defined in\r\n    // the specification (this allows multiple references)\r\n    if (norm) result = _normParams(result);\r\n\r\n    // returns the constructed object to the caller method this object\r\n    // should be a structured representation of the data in the request\r\n    return result;\r\n};\r\n\r\nconst _resolveAlias = function(params) {\r\n    const result = {};\r\n    Object.entries(params).forEach(([key, value]) => {\r\n        result[ALIAS[key] || key] = value;\r\n    });\r\n    return result;\r\n};\r\n\r\nconst _pageTypes = function(params, defaultSize = 50) {\r\n    const result = Object.assign({}, params);\r\n\r\n    const page = parseInt(params.page || 1);\r\n    const size = parseInt(params.size || defaultSize);\r\n    const offset = page - 1;\r\n    result.skip = offset * size;\r\n    result.limit = size;\r\n\r\n    const sorter = params.sorter;\r\n    const direction = params.direction || \"descending\";\r\n    if (sorter) result.sort = `${sorter}:${direction}`;\r\n\r\n    return result;\r\n};\r\n\r\nconst _toSort = function(value) {\r\n    const values = value.split(\":\", 2);\r\n    if (values.length === 1) values.push(\"descending\");\r\n    const [name, direction] = values;\r\n    if (name === \"default\") return null;\r\n    values[1] = SORT_MAP[direction] || 1;\r\n    return [values];\r\n};\r\n\r\nconst _findTypes = function(params) {\r\n    const result = {};\r\n    Object.entries(params).forEach(([key, value]) => {\r\n        const converter = FIND_TYPES[key];\r\n        const converted = converter ? converter(value) : value;\r\n        result[key] = converted;\r\n    });\r\n    return result;\r\n};\r\n\r\nconst _findDefaults = function(params, options = {}) {\r\n    const result = Object.assign({}, params);\r\n    Object.entries(options)\r\n        .filter(([key]) => FIND_TYPES[key])\r\n        .forEach(([key, value]) => {\r\n            result[key] = params[key] || value;\r\n        });\r\n    Object.entries(FIND_DEFAULTS).forEach(([key, value]) => {\r\n        result[key] = params[key] || value;\r\n    });\r\n    return result;\r\n};\r\n\r\nconst _normParams = function(params) {\r\n    const result = Object.assign({}, params);\r\n\r\n    // iterates over all the key value association in the object,\r\n    // trying to find the ones that refer sequences so that they\r\n    // may be normalized\r\n    for (const [key, value] of Object.entries(params)) {\r\n        // verifies if the current name references a sequence and\r\n        // if that's not the case continues the loop trying to find\r\n        // any other sequence based value\r\n        if (!key.endsWith(\"[]\")) {\r\n            result[key] = value;\r\n            continue;\r\n        }\r\n\r\n        // removes the extra sequence indication value\r\n        const name = key.substring(0, key.length - 2);\r\n\r\n        // in case the current value is not valid (empty) the object\r\n        // is set with an empty list for the current iteration as this\r\n        // is considered to be the default value\r\n        if (!value) {\r\n            result[name] = [];\r\n            continue;\r\n        }\r\n\r\n        // retrieves the normalized and linearized list of leafs\r\n        // for the current value and ten verifies the size of each\r\n        // of its values and uses it to measure the number of\r\n        // dictionary elements that are going to be contained in\r\n        // the sequence to be \"generated\", then uses this (size)\r\n        // value to pre-generate the complete set of dictionaries\r\n        const leafs = _leafs(value);\r\n        const [, values] = leafs[0] || [null, []];\r\n        const list = values.map(_ => ({}));\r\n\r\n        // sets the list of generates dictionaries in the object for\r\n        // the newly normalized name of structure\r\n        result[name] = list;\r\n\r\n        // iterates over the complete set of key value pairs in the\r\n        // leafs list to gather the value into the various objects that\r\n        // are contained in the sequence (normalization process)\r\n        for (const [name, value] of leafs) {\r\n            for (let index; index < list.length; index++) {\r\n                const object = list[index];\r\n                const nameList = name.split(\".\");\r\n                _setObject(object, nameList, value[index]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Retrieves a list containing a series of tuples that each represent a\r\n * leaf of the current object structure. A leaf is the last element of an\r\n * object that is not a map, the other intermediary maps are considered to\r\n * be trunks and should be percolated recursively.\r\n * This is a recursive function that takes some memory for the construction\r\n * of the list, and so should be used with the proper care to avoid bottlenecks.\r\n *\r\n * @param {Object} params The object for which the leafs list structure is\r\n * meant to be retrieved.\r\n * @returns {Array} The list of leaf node tuples for the provided object,\r\n * as requested for each of the sequences.\r\n */\r\nconst _leafs = function(params) {\r\n    // the list that will hold the various leaf nodes \"gathered\" by\r\n    // the current recursion function\r\n    let result = [];\r\n\r\n    // iterates over all the key and value relations in the object trying\r\n    // to find the leaf nodes (no map nodes) creating a tuple of fqn\r\n    // (fully qualified name) and value\r\n    for (const [key, value] of Object.entries(params)) {\r\n        // retrieves the data type for the current value and validation\r\n        // if it is a object or any other type in case it's an object a\r\n        // new iteration step must be performed retrieving the leafs of\r\n        // the value and then incrementing the name with the current prefix\r\n        if (typeof value === \"object\") {\r\n            const leafs = _leafs(value).map(([name, value]) => [`${key}.${name}`, value]);\r\n            result = Array.concat(result, leafs);\r\n        } else {\r\n            // otherwise this is a leaf node and so the leaf tuple node\r\n            // must be constructed with the current value (properly validated\r\n            // for sequence presence)\r\n            result.push([key, Array.isArray(value) ? value : [value]]);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Sets a composite value in an object, allowing for dynamic setting of\r\n * random size key values.\r\n * This method is useful for situations where one wants to set a value\r\n * at a randomly defined depth inside an object without having to much\r\n * work with the creation of the inner dictionaries.\r\n *\r\n * @param {Object} object The target object that is going to be\r\n * changed and set with the target value.\r\n * @param {Array} nameList The list of names that defined the fully\r\n * qualified name to be used in the setting of the value\r\n * for example path.to.end will be a three size list containing each\r\n * of the partial names.\r\n * @param {Object} value The value that is going to be set in the\r\n * defined target of the object.\r\n */\r\nconst _setObject = function(object, nameList, value) {\r\n    // retrieves the first name in the names list this is the\r\n    // value that is going to be used for the current iteration\r\n    const [name, ...tail] = nameList[0];\r\n\r\n    // in case the length of the current names list has reached\r\n    // one this is the final iteration and so the value is set\r\n    // at the current naming point\r\n    if (nameList.length === 1) {\r\n        object[name] = value;\r\n    } else {\r\n        // otherwise this is a \"normal\" step and so a new map must\r\n        // be created/retrieved and the iteration step should be\r\n        // performed on this new map as it's set on the current naming\r\n        // place (recursion step)\r\n\r\n        const map = object[name] || {};\r\n        object[name] = map;\r\n        _setObject(map, tail, value);\r\n    }\r\n};\n\nclass MixinBuilder {\r\n    constructor(superclass) {\r\n        this.superclass = superclass;\r\n    }\r\n\r\n    with(...mixins) {\r\n        return mixins.reduce((c, mixin) => mixin(c), this.superclass);\r\n    }\r\n}\r\n\r\nconst mix = superclass => new MixinBuilder(superclass);\n\nconst initMongo = async (mongoose, uri) => {\r\n    mongoose.set(\"useNewUrlParser\", true);\r\n    mongoose.set(\"useFindAndModify\", false);\r\n    mongoose.set(\"useCreateIndex\", true);\r\n    mongoose.set(\"useUnifiedTopology\", true);\r\n    await mongoose.connect(uri, {\r\n        useNewUrlParser: true,\r\n        useUnifiedTopology: true\r\n    });\r\n};\r\n\r\nconst destroyMongo = mongoose => {\r\n    mongoose.disconnect();\r\n};\n\nconst equal = function(first, second) {\r\n    if (first === second) {\r\n        return true;\r\n    }\r\n\r\n    if (typeof_(first) !== typeof_(second)) {\r\n        return false;\r\n    }\r\n\r\n    if (isPrimitive(first) && isPrimitive(second)) {\r\n        return first === second;\r\n    }\r\n\r\n    if (first instanceof Date && second instanceof Date) {\r\n        return first === second;\r\n    }\r\n\r\n    if (Object.keys(first).length !== Object.keys(second).length) {\r\n        return false;\r\n    }\r\n\r\n    for (const key in first) {\r\n        if (!(key in second)) return false;\r\n        if (!equal(first[key], second[key])) return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst isPrimitive = function(object) {\r\n    return object !== Object(object);\r\n};\r\n\r\nconst typeof_ = function(object) {\r\n    if (object === null) return \"null\";\r\n    if (Array.isArray(object)) return \"array\";\r\n    return typeof object;\r\n};\n\nconst matchOperatorsRegex = /[|\\\\{}()[\\]^$+*?.-]/g;\r\n\r\nconst escapeStringRegexp = function(string) {\r\n    if (typeof string !== \"string\") {\r\n        throw new TypeError(\"Expected a string\");\r\n    }\r\n\r\n    return string.replace(matchOperatorsRegex, \"\\\\$&\");\r\n};\n\n/* The default minimum value meaning that this is the\r\nmaximum value that one integer value may have for the\r\nsize rounding operation to be performed */\r\nconst DEFAULT_MINIMUM = 1024;\r\n\r\n/* The default number of places (digits) that are going\r\nto be used for the string representation in the round\r\nbased conversion of size units to be performed */\r\nconst DEFAULT_PLACES = 3;\r\n\r\n/* The size unit coefficient as an integer value, this is\r\ngoing to be used in each of the size steps as divisor */\r\nconst SIZE_UNIT_COEFFICIENT = 1024;\r\n\r\n/* The simplified size units list that contains the complete set of\r\nunits indexed by the depth they represent */\r\nconst SIZE_UNITS_LIST_S = [\"B\", \"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\r\n\r\n/* The size units list that contains the complete set of\r\nunits indexed by the depth they represent */\r\nconst SIZE_UNITS_LIST = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\r\n\r\nconst sizeRoundUnit = function(\r\n    sizeValue,\r\n    minimum = DEFAULT_MINIMUM,\r\n    places = DEFAULT_PLACES,\r\n    reduce = true,\r\n    space = false,\r\n    justify = false,\r\n    simplified = false,\r\n    depth = 0\r\n) {\r\n    // in case the current size value is acceptable (less than\r\n    // the minimum) this is the final iteration and the final\r\n    // string representation is going to be created\r\n    if (sizeValue < minimum) {\r\n        // calculates the maximum size of the string that is going\r\n        // to represent the base size value as the number of places\r\n        // plus one (representing the decimal separator character)\r\n        const sizeS = places + 1;\r\n\r\n        // calculates the target number of decimal places taking\r\n        // into account the size (in digits) of the current size\r\n        // value, this may never be a negative number\r\n        const logValue = sizeValue && Math.log10(sizeValue);\r\n        const digits = Math.trunc(logValue) + 1;\r\n        places = places - digits;\r\n        places = places > 0 ? places : 0;\r\n\r\n        // rounds the size value, then converts the rounded\r\n        // size value into a string based representation\r\n        let sizeValueS = sizeValue.toFixed(places);\r\n\r\n        // forces the reduce flag when the depth is zero, meaning\r\n        // that an integer value will never be decimal, this is\r\n        // required to avoid strange results for depth zero\r\n        reduce = reduce || depth === 0;\r\n\r\n        // in case the dot value is not present in the size value\r\n        // string adds it to the end otherwise an issue may occur\r\n        // while removing extra padding characters for reduce\r\n        if (reduce && !sizeValueS.includes(\".\")) sizeValueS += \".\";\r\n\r\n        // strips the value from zero appended to the right and\r\n        // then strips the value also from a possible decimal\r\n        // point value that may be included in it, this is only\r\n        // performed in case the reduce flag is enabled\r\n        if (reduce) sizeValueS = sizeValueS.replace(/0+$/, \"\");\r\n        if (reduce) sizeValueS = sizeValueS.replace(/\\.$/, \"\");\r\n\r\n        // in case the justify flag is set runs the justification\r\n        // process on the size value taking into account the maximum\r\n        // size of the associated size string\r\n        if (justify) sizeValueS = _rjust(sizeValueS, sizeS);\r\n        // retrieves the size unit (string mode) for the current\r\n        // depth according to the provided map\r\n        let sizeUnit;\r\n        if (simplified) sizeUnit = SIZE_UNITS_LIST_S[depth];\r\n        else sizeUnit = SIZE_UNITS_LIST[depth];\r\n\r\n        // retrieves the appropriate separator based\r\n        // on the value of the space flag\r\n        const separator = (space && \" \") || \"\";\r\n\r\n        // creates the size value string appending the rounded\r\n        // size value string and the size unit and returns it\r\n        // to the caller method as the size value string\r\n        const sizeValueString = sizeValueS + separator + sizeUnit;\r\n        return sizeValueString;\r\n    }\r\n    // otherwise the value is not acceptable and a new iteration\r\n    // must be ran with one less depth of size value\r\n    else {\r\n        // re-calculates the new size value, increments the depth\r\n        // and runs the size round unit again with the new values\r\n        const newSizeValue = parseFloat(sizeValue) / SIZE_UNIT_COEFFICIENT;\r\n        const newDepth = depth + 1;\r\n        return sizeRoundUnit(\r\n            newSizeValue,\r\n            minimum,\r\n            places,\r\n            reduce,\r\n            space,\r\n            justify,\r\n            simplified,\r\n            newDepth\r\n        );\r\n    }\r\n};\r\n\r\nconst _rjust = function(str, length) {\r\n    const lengthToFill = length - str.length;\r\n    return lengthToFill <= 0 ? str : \" \".repeat(lengthToFill) + str;\r\n};\n\nconst camelToUnderscore = function(value, separator = \"_\") {\r\n    if (!value) return value;\r\n    return value\r\n        .replace(/\\.?([A-Z])/g, (x, y) => separator + y.toLowerCase())\r\n        .replace(RegExp(\"^\" + separator), \"\");\r\n};\r\n\r\nconst underscoreToCamel = function(value, lower = false, separator = \"_\") {\r\n    if (!value) return value;\r\n    const slices = value.split(separator);\r\n    return slices\r\n        .map((s, i) => {\r\n            if (i === 0 && lower) return s.charAt(0).toLowerCase() + s.slice(1);\r\n            return s.charAt(0).toUpperCase() + s.slice(1);\r\n        })\r\n        .join(\"\");\r\n};\n\n/**\r\n * Encodes the multiple values as and encoded URI component, the\r\n * values can be wither defined as an array (order is preserved)\r\n * or as an object (where sequence order is not preserved).\r\n *\r\n * The value of each item can be either a primitive type or a sequence\r\n * in case it's of sequence the values are going to be encoded as\r\n * multiple parameters separated by the '&' character.\r\n *\r\n * @param {(Array|Object[])} values The values to be encoded as an\r\n * URI component (like GET params).\r\n * @returns {String} A string with the query encoded values.\r\n */\r\nconst urlEncode = function(values) {\r\n    // constructs the parts array that is going to\r\n    // store the multiple and values\r\n    const parts = [];\r\n\r\n    // in case the provided value is not an array\r\n    // then assumes it's an object and retrieve entries\r\n    if (!Array.isArray(values)) {\r\n        values = Object.entries(values);\r\n    }\r\n\r\n    // iterates over the complete set of pairs available\r\n    // from the key value pairs to be able to encode them\r\n    // properly, notice that the values themselves can be\r\n    // sequences allowing multiple repetition of key\r\n    values.forEach(([key, value]) => {\r\n        if (!Array.isArray(value)) {\r\n            value = [value];\r\n        }\r\n        const keyEncoded = encodeURIComponent(key);\r\n        value.forEach(_value => {\r\n            if (_value === undefined || _value === null) {\r\n                return;\r\n            }\r\n            const valueEncoded = encodeURIComponent(_value);\r\n            parts.push(`${keyEncoded}=${valueEncoded}`);\r\n        });\r\n    });\r\n\r\n    // joins the complete set of parts with the and\r\n    // separator and then returns the final string value\r\n    return parts.join(\"&\");\r\n};\r\n\r\nconst absoluteUrl = function(path, name = \"BASE_URL\", fallback = undefined) {\r\n    const baseUrl = conf(name, fallback);\r\n    if (!baseUrl) return null;\r\n    return `${baseUrl}${path}`;\r\n};\n\nclass YoniusError extends Error {\r\n    constructor(message, code = 500) {\r\n        super(message);\r\n        this.name = this.constructor.name;\r\n        this.code = code;\r\n    }\r\n\r\n    get isClient() {\r\n        return Math.floor(this.code / 100) === 4;\r\n    }\r\n\r\n    get isServer() {\r\n        return Math.floor(this.code / 100) === 5;\r\n    }\r\n}\r\n\r\nclass OperationalError extends YoniusError {\r\n    constructor(message = \"Operational error\", code = 500) {\r\n        super(message, code);\r\n    }\r\n}\r\n\r\nclass NotFoundError extends OperationalError {\r\n    constructor(message = \"Not found\", code = 404) {\r\n        super(message, code);\r\n    }\r\n}\r\n\r\nclass NotImplementedError extends OperationalError {\r\n    constructor(message = \"Not implemented\", code = 501) {\r\n        super(message, code);\r\n    }\r\n}\r\n\r\nclass ValidationError extends OperationalError {\r\n    constructor(message = \"Validation of submitted data failed\", code = 400) {\r\n        super(message, code);\r\n    }\r\n}\r\n\r\nclass AttributeError extends YoniusError {\r\n    constructor(message = \"Attribute not found\") {\r\n        super(message);\r\n    }\r\n}\n\n/**\r\n * The simple regex used to validate\r\n * if the provided value is a \"simple\" one meaning\r\n * that it may be used safely for URL parts\r\n */\r\nconst SIMPLE_REGEX = /^[\\:\\.\\s\\w-]+$/;\r\n\r\n/**\r\n * The email regex used to validate\r\n * if the provided value is in fact an email\r\n */\r\nconst EMAIL_REGEX = /^[\\w\\d\\._%+-]+@[\\w\\d\\.\\-]+$/;\r\n\r\n/**\r\n * The URL regex used to validate\r\n * if the provided value is in fact an URL/URI\r\n */\r\nconst URL_REGEX = /^\\w+\\:\\/\\/([^@]+\\:[^@]+@)?[^\\:\\/\\?#]+(\\:\\d+)?(\\/[^\\?#]+)*\\/?(\\?[^#]*)?(#.*)?$/;\r\n\r\nconst eq = function(valueC, message = \"Must be equal to %{1}\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst gt = function(valueC, message = \"Must be greater than %{1}\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value > valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst gte = function(valueC, message = \"Must be greater than or equal to %{1}\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value >= valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst notEmpty = function(message = \"Value is empty\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value.length) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isIn = function(valueC, message = \"Value must be one of: %{1}\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (valueC.includes(value)) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", valueC.join(\", \")));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isUpper = function(message = \"Value contains lower cased characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value === value.toUpperCase()) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isLower = function(message = \"Value contains upper cased characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value === value.toLowerCase()) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isSimple = function(message = \"Value contains invalid characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value.match(SIMPLE_REGEX)) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isEmail = function(message = \"Value is not a valid email\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value.match(EMAIL_REGEX)) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isUrl = function(message = \"Value is not a valid URL\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value.match(URL_REGEX)) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isRegex = function(regex, message = \"Value has incorrect format\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value.match(new RegExp(regex))) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst stringGt = function(valueC, message = \"Must be larger than %{1} characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value.length > valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst stringLt = function(valueC, message = \"Must be smaller than %{1} characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value.length < valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst stringEq = function(valueC, message = \"Must be exactly %{1} characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value.length === valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst all = function(validation) {\r\n    const _validation = (sequence, ctx) => {\r\n        if (sequence === undefined) return true;\r\n        if (sequence === null) return true;\r\n        for (const value of sequence) {\r\n            validation(value, ctx);\r\n        }\r\n        return true;\r\n    };\r\n    return _validation;\r\n};\n\nconst AUTH_ERRORS = [401, 403, 440, 499];\r\n\r\nclass API extends Observable {\r\n    constructor(kwargs = {}) {\r\n        super();\r\n        this.kwargs = kwargs;\r\n    }\r\n\r\n    async build(method, url, options = {}) {}\r\n\r\n    async authCallback(params, headers) {}\r\n\r\n    async get(url, options = {}) {\r\n        const result = await this.methodBasic(\"GET\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async post(url, options = {}) {\r\n        const result = await this.methodPayload(\"POST\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async put(url, options = {}) {\r\n        const result = await this.methodPayload(\"PUT\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async delete(url, options = {}) {\r\n        const result = await this.methodBasic(\"DELETE\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async patch(url, options = {}) {\r\n        const result = await this.methodPayload(\"PATCH\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async options(url, options = {}) {\r\n        const result = await this.methodBasic(\"OPTIONS\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async methodBasic(method, url, options = {}) {\r\n        options.params = options.params !== undefined ? options.params : {};\r\n        options.headers = options.headers !== undefined ? options.headers : {};\r\n        try {\r\n            return await this._methodBasic(method, url, options);\r\n        } catch (err) {\r\n            if (AUTH_ERRORS.includes(err.code)) {\r\n                await this.authCallback(options.params, options.headers);\r\n                return await this._methodBasic(method, url, options);\r\n            } else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    async methodPayload(method, url, options = {}) {\r\n        options.params = options.params !== undefined ? options.params : {};\r\n        options.headers = options.headers !== undefined ? options.headers : {};\r\n        try {\r\n            return await this._methodPayload(method, url, options);\r\n        } catch (err) {\r\n            if (AUTH_ERRORS.includes(err.code)) {\r\n                await this.authCallback(options.params, options.headers);\r\n                return await this._methodPayload(method, url, options);\r\n            } else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    async _methodBasic(method, url, options = {}) {\r\n        const params = options.params !== undefined ? options.params : {};\r\n        const headers = options.headers !== undefined ? options.headers : {};\r\n        const kwargs = options.kwargs !== undefined ? options.kwargs : {};\r\n        const handle = options.handle !== undefined ? options.handle : true;\r\n        const getAgent = options.getAgent !== undefined ? options.getAgent : undefined;\r\n        await this.build(method, url, {\r\n            params: params,\r\n            headers: headers,\r\n            kwargs: kwargs\r\n        });\r\n        const query = urlEncode(params || {});\r\n        if (query) url += url.includes(\"?\") ? \"&\" + query : \"?\" + query;\r\n        const response = await fetch(url, {\r\n            method: method,\r\n            headers: headers || {},\r\n            agent: getAgent || globals.getAgent || undefined\r\n        });\r\n        const result = handle ? await this._handleResponse(response) : response;\r\n        return result;\r\n    }\r\n\r\n    async _methodPayload(method, url, options = {}) {\r\n        const params = options.params !== undefined ? options.params : {};\r\n        let headers = options.headers !== undefined ? options.headers : {};\r\n        let data = options.data !== undefined ? options.data : null;\r\n        const dataJ = options.dataJ !== undefined ? options.dataJ : null;\r\n        const dataM = options.dataM !== undefined ? options.dataM : null;\r\n        let mime = options.mime !== undefined ? options.mime : null;\r\n        const kwargs = options.kwargs !== undefined ? options.kwargs : {};\r\n        const handle = options.handle !== undefined ? options.handle : true;\r\n        const getAgent = options.getAgent !== undefined ? options.getAgent : undefined;\r\n\r\n        await this.build(method, url, {\r\n            params: params,\r\n            headers: headers,\r\n            data: data,\r\n            dataJ: dataJ,\r\n            dataM: dataM,\r\n            mime: mime,\r\n            kwargs: kwargs\r\n        });\r\n\r\n        const query = urlEncode(params || {});\r\n\r\n        if (data !== null) {\r\n            if (query) url += url.includes(\"?\") ? \"&\" + query : \"?\" + query;\r\n        } else if (dataJ !== null) {\r\n            data = JSON.stringify(dataJ);\r\n            if (query) url += url.includes(\"?\") ? \"&\" + query : \"?\" + query;\r\n            mime = mime || \"application/json\";\r\n        } else if (dataM !== null) {\r\n            if (query) url += url.includes(\"?\") ? \"&\" + query : \"?\" + query;\r\n            [mime, data] = this._encodeMultipart(dataM, mime, true);\r\n        } else if (query) {\r\n            data = query;\r\n            mime = mime || \"application/x-www-form-urlencoded\";\r\n        }\r\n\r\n        headers = Object.assign({}, headers);\r\n        if (mime) headers[\"Content-Type\"] = mime;\r\n\r\n        const response = await fetch(url, {\r\n            method: method,\r\n            headers: headers || {},\r\n            body: data,\r\n            agent: getAgent || global.getAgent || undefined\r\n        });\r\n        const result = handle ? await this._handleResponse(response) : response;\r\n        return result;\r\n    }\r\n\r\n    async _handleResponse(response, errorMessage = \"Problem in request\") {\r\n        let result = null;\r\n        if (\r\n            response.headers.get(\"content-type\") &&\r\n            response.headers.get(\"content-type\").toLowerCase().startsWith(\"application/json\")\r\n        ) {\r\n            result = await response.json();\r\n        } else if (\r\n            response.headers.get(\"content-type\") &&\r\n            response.headers.get(\"content-type\").toLowerCase().startsWith(\"text/\")\r\n        ) {\r\n            result = await response.text();\r\n        } else {\r\n            result = await response.blob();\r\n        }\r\n        verify(response.ok, result.error || errorMessage, response.status || 500);\r\n        return result;\r\n    }\r\n\r\n    _encodeMultipart(fields, mime = null, doseq = false) {\r\n        mime = mime || \"multipart/form-data\";\r\n\r\n        const boundary = this._createBoundary(fields, undefined, doseq);\r\n\r\n        const encoder = new TextEncoder(\"utf-8\");\r\n\r\n        const buffer = [];\r\n\r\n        for (let [key, values] of Object.entries(fields)) {\r\n            const isList = doseq && Array.isArray(values);\r\n            values = isList ? values : [values];\r\n\r\n            for (let value of values) {\r\n                if (value === null) continue;\r\n\r\n                let header;\r\n\r\n                if (\r\n                    typeof value === \"object\" &&\r\n                    !(value instanceof Array) &&\r\n                    value.constructor !== Uint8Array\r\n                ) {\r\n                    const headerL = [];\r\n                    let data = null;\r\n                    for (const [key, item] of Object.entries(value)) {\r\n                        if (key === \"data\") data = item;\r\n                        else headerL.push(`${key}: ${item}`);\r\n                    }\r\n                    value = data;\r\n                    header = headerL.join(\"\\r\\n\");\r\n                } else if (value instanceof Array) {\r\n                    let name = null;\r\n                    let contents = null;\r\n                    let contentTypeD = null;\r\n                    if (value.length === 2) [name, contents] = value;\r\n                    else [name, contentTypeD, contents] = value;\r\n                    header = `Content-Disposition: form-data; name=\"${key}\"; filename=\"${name}\"`;\r\n                    if (contentTypeD) header += `\\r\\nContent-Type: ${contentTypeD}`;\r\n                    value = contents;\r\n                } else {\r\n                    header = `Content-Disposition: form-data; name=\"${key}\"`;\r\n                    value = value.constructor === Uint8Array ? value : encoder.encode(value);\r\n                }\r\n\r\n                buffer.push(encoder.encode(\"--\" + boundary + \"\\r\\n\"));\r\n                buffer.push(encoder.encode(header + \"\\r\\n\"));\r\n                buffer.push(encoder.encode(\"\\r\\n\"));\r\n                buffer.push(value);\r\n                buffer.push(encoder.encode(\"\\r\\n\"));\r\n            }\r\n        }\r\n\r\n        buffer.push(encoder.encode(\"--\" + boundary + \"--\\r\\n\"));\r\n        buffer.push(encoder.encode(\"\\r\\n\"));\r\n        const body = this._joinBuffer(buffer);\r\n        const contentType = `${mime}; boundary=${boundary}`;\r\n\r\n        return [contentType, body];\r\n    }\r\n\r\n    _createBoundary(fields, size = 32, doseq = false) {\r\n        return \"Vq2xNWWHbmWYF644q9bC5T2ALtj5CynryArNQRXGYsfm37vwFKMNsqPBrpPeprFs\";\r\n    }\r\n\r\n    _joinBuffer(bufferArray) {\r\n        const bufferSize = bufferArray.map(item => item.byteLength).reduce((a, v) => a + v, 0);\r\n        const buffer = new Uint8Array(bufferSize);\r\n        let offset = 0;\r\n        for (const item of bufferArray) {\r\n            buffer.set(item, offset);\r\n            offset += item.byteLength;\r\n        }\r\n        return buffer;\r\n    }\r\n}\r\n\r\nconst buildGetAgent = (AgentHttp, AgentHttps, set = true, options = {}) => {\r\n    const httpAgent = new AgentHttp({\r\n        keepAlive: options.keepAlive === undefined ? true : options.keepAlive,\r\n        keepAliveMsecs: options.keepAliveMsecs || 120000,\r\n        timeout: options.timeout || 60000,\r\n        scheduling: options.scheduling || \"fifo\"\r\n    });\r\n    const httpsAgent = new AgentHttps({\r\n        keepAlive: options.keepAlive === undefined ? true : options.keepAlive,\r\n        keepAliveMsecs: options.keepAliveMsecs || 120000,\r\n        timeout: options.timeout || 60000,\r\n        scheduling: options.scheduling || \"fifo\"\r\n    });\r\n    const getAgent = parsedURL => (parsedURL.protocol === \"http:\" ? httpAgent : httpsAgent);\r\n    if (set) globals.getAgent = getAgent;\r\n    return getAgent;\r\n};\r\n\r\n/**\r\n * Tries to patch the global environment with a proper `getAgent`\r\n * function that can handle HTTP and HTTP connection polling.\r\n *\r\n * This can only be performed in a node.js environment (uses `require`).\r\n *\r\n * @returns {Function} The `getAgent` function that has just been\r\n * built and set in the globals.\r\n */\r\nconst patchAgent = () => {\r\n    if (typeof require !== \"function\") return;\r\n    if (globals.getAgent) return;\r\n    let http, https;\r\n    try {\r\n        http = require(\"http\");\r\n        https = require(\"https\");\r\n    } catch (err) {\r\n        return;\r\n    }\r\n    if (!http || !https) return;\r\n    if (!http.Agent || !https.Agent) return;\r\n    return buildGetAgent(http.Agent, https.Agent, true);\r\n};\r\n\r\n// patches the global agent if possible, using the\r\n// global dynamic require statements\r\npatchAgent();\n\nclass OAuthAPI extends API {}\n\nclass OAuth1API extends OAuthAPI {}\n\nclass OAuth2API extends OAuthAPI {\r\n    constructor(kwargs = {}) {\r\n        super(kwargs);\r\n        this.accessToken = null;\r\n    }\r\n\r\n    async build(method, url, options = {}) {\r\n        await super.build(method, url, options);\r\n        const params = options.params !== undefined ? options.params : {};\r\n        const headers = options.headers !== undefined ? options.headers : {};\r\n        const kwargs = options.kwargs !== undefined ? options.kwargs : {};\r\n        const token = kwargs.token === undefined ? this.tokenDefault : kwargs.token;\r\n        delete kwargs.token;\r\n        if (token && this.oauthTypes.includes(\"param\")) {\r\n            params[this.oauthParam] = this.getAccessToken();\r\n        }\r\n        if (token && this.oauthTypes.includes(\"header\")) {\r\n            headers.Authorization = `Bearer ${this.getAccessToken()}`;\r\n        }\r\n    }\r\n\r\n    getAccessToken() {\r\n        if (this.accessToken) return this.accessToken;\r\n        throw new Error(\"No access token found must re-authorize\");\r\n    }\r\n\r\n    get oauthTypes() {\r\n        return [\"param\", \"header\"];\r\n    }\r\n\r\n    get oauthParam() {\r\n        return \"access_token\";\r\n    }\r\n\r\n    get tokenDefault() {\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * Ensures that the current \"session\" context contains the\r\n * requested ACL token as valid.\r\n *\r\n * In case the validation fails an exception is raised\r\n * indicating the auth validation error.\r\n *\r\n * @param {String} token The ACL token to ensure permission,\r\n * the logged user should be allowed to id.\r\n * @param {Object} ctx The context object to be used in\r\n * the session basic ACL retrieval, should contain proper\r\n * injected methods for retrieval (eg: `getAcl`).\r\n */\r\nconst ensurePermissions = async (token, ctx) => {\r\n    // retrieves the ACL values from the current context and\r\n    // then uses the ACL to obtain the valid expanded tokens map\r\n    const acl = ctx.getAcl ? await ctx.getAcl(ctx) : {};\r\n    const tokens = toTokensM(acl);\r\n\r\n    // in case the permission validation test is not positive\r\n    // then an exception should be raised indicating the issue\r\n    if (!hasPermission(token, tokens)) {\r\n        throw new OperationalError(\"You don't have authorization to access this resource\", 401);\r\n    }\r\n};\r\n\r\n/**\r\n * Converts the provided list of token strings separated by dots\r\n * into a map based representation on an hierarchical structure.\r\n *\r\n * @param {Array} tokens A linear array of tokens to convert into\r\n * an hierarchical representation.\r\n * @returns {Object} The map containing the hierarchy of tokens\r\n * for the provided linear string based sequence of tokens.\r\n */\r\nconst toTokensM = tokens => {\r\n    const tokensM = {};\r\n\r\n    if (tokens === undefined) return tokensM;\r\n    if (tokens === null) return tokensM;\r\n    if (!Array.isArray(tokens)) return tokensM;\r\n\r\n    for (const token of tokens) {\r\n        let tokensC = tokensM;\r\n        const tokenL = token.split(\".\");\r\n        const head = tokenL.slice(0, tokenL.length - 1);\r\n        const tail = tokenL[tokenL.length - 1];\r\n\r\n        for (const tokenP of head) {\r\n            let current = tokensC[tokenP] || {};\r\n            const isDict = typeof current === \"object\";\r\n            if (!isDict) current = { _: current };\r\n            tokensC[tokenP] = current;\r\n            tokensC = current;\r\n        }\r\n\r\n        const leaf = tokensC[tail] || null;\r\n        if (leaf && typeof leaf === \"object\") leaf._ = true;\r\n        else tokensC[tail] = true;\r\n    }\r\n\r\n    return tokensM;\r\n};\r\n\r\nconst hasPermission = (token, tokensM = null) => {\r\n    if (!token) return true;\r\n    if (tokensM === undefined || tokensM === null) return false;\r\n\r\n    const tokenL = token.split(\".\");\r\n    for (const tokenP of tokenL) {\r\n        if (typeof tokensM !== \"object\") return false;\r\n        if (tokensM[\"*\"]) return true;\r\n        if (tokensM[tokenP] === undefined) return false;\r\n        tokensM = tokensM[tokenP];\r\n    }\r\n\r\n    const isDict = typeof tokensM === \"object\";\r\n    const result = isDict ? tokensM._ || false : tokensM;\r\n\r\n    return Boolean(result);\r\n};\n\nconst REGISTRY = {};\r\n\r\nconst load = async function() {\r\n    await load$1();\r\n};\r\n\r\nconst unload = async function() {};\r\n\r\nconst register = function(name, value) {\r\n    REGISTRY[name] = value;\r\n};\r\n\r\nconst unregister = function(name) {\r\n    delete REGISTRY[name];\r\n};\r\n\r\nconst request = function(name) {\r\n    if (REGISTRY[name] === undefined) {\r\n        throw new OperationalError(`Name '${name}' not found in registry`);\r\n    }\r\n    return REGISTRY[name];\r\n};\n\nclass FileTuple extends Array {\r\n    static fromData(data, name = null, mime = null) {\r\n        const fileTuple = new this(name, mime, data);\r\n        return fileTuple;\r\n    }\r\n\r\n    static fromString(dataString, name = null, mime = null, { encoding = \"utf-8\" } = {}) {\r\n        const data = new TextEncoder(encoding).encode(dataString);\r\n        return this.fromData(data, name, mime);\r\n    }\r\n\r\n    static fromArrayBuffer(arrayBuffer, name = null, mime = null) {\r\n        const buffer = Buffer.from(arrayBuffer);\r\n        return this.fromData(buffer, name, mime);\r\n    }\r\n\r\n    static async fromBlob(blob, name = null, mime = null) {\r\n        const arrayBuffer = await blob.arrayBuffer();\r\n        return this.fromArrayBuffer(arrayBuffer, name, mime);\r\n    }\r\n\r\n    get name() {\r\n        return this[0];\r\n    }\r\n\r\n    get mime() {\r\n        return this[1];\r\n    }\r\n\r\n    get data() {\r\n        return this[2];\r\n    }\r\n}\n\nclass AbstractType {\r\n    async jsonV() {\r\n        return JSON.stringify(this);\r\n    }\r\n\r\n    async mapV() {\r\n        const result = await this.jsonV();\r\n        return result;\r\n    }\r\n}\r\n\r\nclass Reference extends AbstractType {}\r\n\r\nconst reference = function(target, { name = null, dumpall = false } = {}) {\r\n    name = name || \"id\";\r\n    const targetT = target.constructor.name;\r\n    const isReference = targetT === \"string\";\r\n    const reserved = [\"id\", \"_target\", \"_object\", \"_type\", \"__dict__\"];\r\n\r\n    class _Reference extends Reference {\r\n        constructor(id) {\r\n            super(id);\r\n\r\n            this.__start__();\r\n\r\n            const proxy = new Proxy(this, {\r\n                get(target, name) {\r\n                    // special case to avoid this Proxy\r\n                    // breaking when being accessed in\r\n                    // an async context\r\n                    if (name === \"then\") return target.then;\r\n\r\n                    if (name in target) return target[name];\r\n\r\n                    const exists = Boolean(target._object && target._object[name]);\r\n                    if (exists) return target._object[name];\r\n                    if (target.isResolved) throw new AttributeError(`'${name}' not found`);\r\n                    return target.get(name);\r\n                },\r\n                set(target, name, value) {\r\n                    if (name in target) {\r\n                        target[name] = value;\r\n                        return true;\r\n                    }\r\n\r\n                    // verifies if the reference object exists in the current\r\n                    // reference instance, that's the case if the object name is\r\n                    // defined in the dictionary and the referenced object contains\r\n                    // an attribute with the name referred, for those situations\r\n                    // defers the setting of the attribute to the reference object\r\n                    const exists =\r\n                        target._object !== undefined && target._object[name] !== undefined;\r\n                    if (exists) {\r\n                        target._object[name] = value;\r\n                        return true;\r\n                    }\r\n\r\n                    // otherwise this is a normal attribute setting and the current\r\n                    // object's dictionary must be changed so that the new value is set\r\n                    target[name] = value;\r\n                    return true;\r\n                }\r\n            });\r\n\r\n            if (id instanceof _Reference) return this.buildI(id);\r\n            else if (id instanceof this.constructor._target) return this.buildO(id);\r\n            else this.build(id);\r\n\r\n            return proxy;\r\n        }\r\n\r\n        static get schema() {\r\n            return target.schema;\r\n        }\r\n\r\n        static get schemaSafe() {\r\n            return target.schemaSafe;\r\n        }\r\n\r\n        static get collection() {\r\n            return target.collection;\r\n        }\r\n\r\n        static get idName() {\r\n            return \"id\";\r\n        }\r\n\r\n        static get increments() {\r\n            return target.increments;\r\n        }\r\n\r\n        static get dataOptions() {\r\n            return target.dataOptions;\r\n        }\r\n\r\n        static _collection(options) {\r\n            return target._collection(options);\r\n        }\r\n\r\n        static async _increment(name) {\r\n            return target._increment(name);\r\n        }\r\n\r\n        static async _ensureMin(name, value) {\r\n            return target._ensureMin(name, value);\r\n        }\r\n\r\n        static _eagerB(eager) {\r\n            return target._eagerB(eager);\r\n        }\r\n\r\n        async get(name) {\r\n            await this.resolve();\r\n            const value = this._object[name];\r\n            if (value === undefined) throw new AttributeError(`'${name}' not found`);\r\n            return value;\r\n        }\r\n\r\n        async set(name, value) {\r\n            // in case the name that is being set is not part of the reserved\r\n            // names for the reference underlying structure the object resolution\r\n            // is triggered to make sure the underlying object exists and is loaded\r\n            if (!reserved.includes(name)) {\r\n                await target.resolve();\r\n            }\r\n\r\n            // verifies if the reference object exists in the current\r\n            // reference instance, that's the case if the object name is\r\n            // defined in the dictionary and the referenced object contains\r\n            // an attribute with the name referred, for those situations\r\n            // defers the setting of the attribute to the reference object\r\n            const exists = this._object !== undefined && this._object[name] !== undefined;\r\n            if (exists) {\r\n                this._object[name] = value;\r\n                return true;\r\n            }\r\n\r\n            // otherwise this is a normal attribute setting and the current\r\n            // object's dictionary must be changed so that the new value is set\r\n            this[name] = value;\r\n        }\r\n\r\n        __start__() {\r\n            if (isReference) this._target = this.constructor._target;\r\n            else this._target = target;\r\n            verify(this._target);\r\n            const meta = this._target.schema[name];\r\n            this._type = meta.type || String;\r\n        }\r\n\r\n        /**\r\n         * The name of the key (join) attribute for the\r\n         * reference that is going to be created, this\r\n         * name may latter be used to cast the value\r\n         */\r\n        static get _name() {\r\n            return name;\r\n        }\r\n\r\n        static get _default() {\r\n            return new this(null);\r\n        }\r\n\r\n        static get _target() {\r\n            if (isReference) {\r\n                throw new NotImplementedError(\"References only work with classes, not class names\");\r\n            }\r\n            return target;\r\n        }\r\n\r\n        static _btype() {\r\n            let _target;\r\n            if (isReference) _target = this._target();\r\n            else _target = target;\r\n            const meta = _target.schema[name];\r\n            return meta.type || String;\r\n        }\r\n\r\n        build(id, cast = true) {\r\n            const isUnset = [\"\", null, undefined].includes(id);\r\n            cast = cast && !isUnset;\r\n            if (cast) id = this.constructor._target.cast(name, id);\r\n            this.id = id;\r\n            this._object = null;\r\n        }\r\n\r\n        buildI(reference) {\r\n            this.id = reference.id;\r\n            this._object = reference._object;\r\n        }\r\n\r\n        buildO(object) {\r\n            this.id = object[this.constructor._name];\r\n            this._object = object;\r\n        }\r\n\r\n        async refV() {\r\n            return this.val;\r\n        }\r\n\r\n        async jsonV() {\r\n            if (dumpall) {\r\n                const result = await this.resolve();\r\n                return result;\r\n            }\r\n            return this.val;\r\n        }\r\n\r\n        async mapV() {\r\n            throw new NotImplementedError();\r\n        }\r\n\r\n        get val() {\r\n            const isEmpty = [\"\", null, undefined].includes(this.id);\r\n            if (isEmpty) return null;\r\n            return this._type(this.id);\r\n        }\r\n\r\n        async resolve(kwargs = {}) {\r\n            // verifies if the underlying object reference exists\r\n            // in the current names dictionary and if it exists\r\n            // verifies if it's valid (value is valid) if that's\r\n            // the case returns the current value immediately\r\n            const exists = this._object !== undefined;\r\n            if (exists && this._object) return this._object;\r\n\r\n            // verifies if there's an id value currently set in\r\n            // the reference in case it does not exists sets the\r\n            // object value in the current instance with a none\r\n            // value and then returns this (invalid value)\r\n            if (!this.id) {\r\n                const _object = null;\r\n                this._object = _object;\r\n                return _object;\r\n            }\r\n\r\n            // creates the map of keyword based arguments that are going\r\n            // to be used in the resolution of the reference and uses the\r\n            // data source based get attribute to retrieve the object\r\n            // that represents the reference\r\n            kwargs[name] = this.constructor._target.cast(name, this.id);\r\n            kwargs.raiseE = kwargs.raiseE || false;\r\n            kwargs.eagerL = kwargs.eagerL || false;\r\n            kwargs.resolveA = kwargs.resolveA || false;\r\n            const _object = await this.constructor._target.get(kwargs);\r\n\r\n            // sets the resolved object (using the current id attribute)\r\n            // in the current instance's dictionary and then returns this\r\n            // value to the caller method as the resolved value\r\n            this._object = _object;\r\n            return _object;\r\n        }\r\n\r\n        get isResolved() {\r\n            const exists = this._object !== undefined;\r\n            return Boolean(exists && this._object);\r\n        }\r\n\r\n        async isResolvable() {\r\n            await this.resolve();\r\n            return this._object !== null;\r\n        }\r\n    }\r\n\r\n    return _Reference;\r\n};\r\n\r\nclass References extends AbstractType {}\r\n\r\nconst references = function(target, { name = undefined, dumpall = false } = {}) {\r\n    name = name || \"id\";\r\n    const targetT = target.constructor.name;\r\n    const isReference = targetT === \"string\";\r\n    const ReferenceC = reference(target, { name: name, dumpall: dumpall });\r\n\r\n    class _References extends References {\r\n        constructor(ids) {\r\n            super(ids);\r\n\r\n            this.__start__();\r\n\r\n            const proxy = new Proxy(this, {\r\n                get(target, name) {\r\n                    if (name in target) return target[name];\r\n                    return target.objects[name];\r\n                }\r\n            });\r\n\r\n            if (ids instanceof _References) return this.buildI(ids);\r\n            else this.build(ids);\r\n\r\n            return proxy;\r\n        }\r\n\r\n        __start__() {\r\n            if (isReference) this._target = this.constructor._target;\r\n            else this._target = target;\r\n            verify(this._target);\r\n        }\r\n\r\n        /**\r\n         * The name of the key (join) attribute for the\r\n         * reference that is going to be created, this\r\n         * name may latter be used to cast the value\r\n         */\r\n        static get _name() {\r\n            return name;\r\n        }\r\n\r\n        static get _default() {\r\n            return new this([]);\r\n        }\r\n\r\n        static get _target() {\r\n            return ReferenceC._target;\r\n        }\r\n\r\n        static _btype() {\r\n            return ReferenceC._btype;\r\n        }\r\n\r\n        get items() {\r\n            return this.objects;\r\n        }\r\n\r\n        build(ids) {\r\n            const isValid = ![null, undefined].includes(ids);\r\n            if (isValid && !Array.isArray(ids)) ids = [ids];\r\n\r\n            this.ids = ids;\r\n            this.objects = [];\r\n            this.objectsM = {};\r\n\r\n            this.setIds(this.ids);\r\n        }\r\n\r\n        buildI(references) {\r\n            this.ids = references.ids;\r\n            this.objects = references.objects;\r\n            this.objectsM = references.objectsM;\r\n        }\r\n\r\n        setIds(ids = []) {\r\n            this.ids = [];\r\n            ids.forEach(id => {\r\n                if ([\"\", null, undefined].includes(id)) return;\r\n                const object = new ReferenceC(id);\r\n                const objectId = object.id;\r\n                this.ids.push(objectId);\r\n                this.objects.push(object);\r\n                this.objectsM[objectId] = object;\r\n            });\r\n        }\r\n\r\n        async refV() {\r\n            const result = await Promise.all(this.objects.map(async object => await object.refV()));\r\n            return result;\r\n        }\r\n\r\n        async jsonV() {\r\n            const result = await Promise.all(\r\n                this.objects.map(async object => await object.jsonV())\r\n            );\r\n            return result;\r\n        }\r\n\r\n        async mapV() {\r\n            const result = await Promise.all(this.objects.map(async object => await object.mapV()));\r\n            return result;\r\n        }\r\n\r\n        get val() {\r\n            return this.objects.map(object => object.val);\r\n        }\r\n\r\n        get list() {\r\n            return this.objects.map(object => object.val);\r\n        }\r\n\r\n        async resolve(kwargs = {}) {\r\n            const result = await Promise.all(this.objects.map(object => object.resolve(kwargs)));\r\n            return result;\r\n        }\r\n\r\n        find(kwargs = {}) {\r\n            kwargs[name] = {\r\n                $in: this.ids.map(id => this._target.cast(name, id))\r\n            };\r\n            return this._target.find(kwargs);\r\n        }\r\n\r\n        paginate(kwargs = {}) {\r\n            kwargs[name] = {\r\n                $in: this.ids.map(id => this._target.cast(name, id))\r\n            };\r\n            return this._target.paginate(kwargs);\r\n        }\r\n\r\n        get isEmpty() {\r\n            const idsL = self.ids.length;\r\n            return idsL === 0;\r\n        }\r\n\r\n        get isResolved() {\r\n            if (this.objects.length === 0) return true;\r\n            return this.objects[0].isResolved;\r\n        }\r\n    }\r\n\r\n    return _References;\r\n};\n\n/**\r\n * A mapping from yonius types to the schema types to\r\n * be used by the underlying Mongo collection.\r\n */\r\nconst MONGO_TYPES = [\r\n    [Reference, Object],\r\n    [References, Array]\r\n];\r\n\r\n/**\r\n * Abstract class definition that defines the interface\r\n * expected to be implemented by data driven collections\r\n * in the Yonius context.\r\n */\r\nclass Collection {\r\n    constructor(options) {\r\n        this.options = options;\r\n    }\r\n\r\n    async find(conditions, projection = {}, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async findOne(conditions, projection = {}, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async findOneAndUpdate(conditions, data, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async findOneAndDelete(conditions, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async create(data, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async count(conditions, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n}\r\n\r\n/**\r\n * Mongo based collection that implements the collection\r\n * abstract interface applying it to a specific mongodb\r\n * instance. Most of the interface is already \"mongodb\r\n * oriented\", so only a thin layer of adaptation is required.\r\n */\r\nclass MongoCollection extends Collection {\r\n    constructor(name, schema) {\r\n        super(name, schema);\r\n        this._mongoose = this.constructor.getModel(this.options.name, this.options.schema);\r\n    }\r\n\r\n    static getModel(name, schema) {\r\n        // verifies if the model is already present in the global\r\n        // cache and if that the case re-uses it\r\n        this._models = this._models || {};\r\n        if (this._models[name]) return this._models[name];\r\n\r\n        // obtains a reference to the mongoose, that\r\n        // should have been registered by 3rd party\r\n        const mongoose = request(\"mongoose\");\r\n\r\n        // creates the internal \"mongoose\" reference to the\r\n        // model by encapsulating its name and schema\r\n        const filteredSchema = { ...schema };\r\n        Object.entries(filteredSchema).forEach(([name, value]) => {\r\n            const found = MONGO_TYPES.find(\r\n                ([type, mongoType]) => value.type.prototype instanceof type\r\n            );\r\n            if (!found) return;\r\n            filteredSchema[name].type = found[1];\r\n        });\r\n        this._models[name] = mongoose.model(name, new mongoose.Schema(filteredSchema));\r\n\r\n        // returns the newly constructor mongoose model to\r\n        // the caller methods\r\n        return this._models[name];\r\n    }\r\n\r\n    async find(conditions, projection = {}, options = {}) {\r\n        const model = await this._mongoose.find(conditions, projection, options);\r\n        return model;\r\n    }\r\n\r\n    async findOne(conditions, projection = {}, options = {}) {\r\n        const model = this._mongoose.findOne(conditions, projection, options);\r\n        return model;\r\n    }\r\n\r\n    async findOneAndUpdate(conditions, data, options = {}) {\r\n        const model = await this._mongoose.findOneAndUpdate(conditions, data, {\r\n            upsert: true,\r\n            new: true,\r\n            ...options\r\n        });\r\n        return model;\r\n    }\r\n\r\n    async findOneAndDelete(conditions, options = {}) {\r\n        const model = await this._mongoose.findOneAndDelete(conditions, options);\r\n        return model;\r\n    }\r\n\r\n    async create(data, options = {}) {\r\n        const models = await this._mongoose.create([data], options);\r\n        return models[0];\r\n    }\r\n\r\n    async count(conditions, options = {}) {\r\n        const count = await this._mongoose.countDocuments(conditions);\r\n        return count;\r\n    }\r\n}\n\nvar collection = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Collection: Collection,\n    MongoCollection: MongoCollection,\n    'default': Collection\n});\n\nconst MEMORY_STORAGE = {};\r\n\r\n/**\r\n * Simple lambda function that removes any\r\n * empty element from the provided list values\r\n */\r\nconst RE = v => v.filter(i => i !== \"\");\r\n\r\n/**\r\n * The map associating the various types with the\r\n * custom builder functions to be used when applying\r\n * the types function, this is relevant for the built-in\r\n * types that are meant to avoid using the default constructor\r\n */\r\nconst BUILDERS = {\r\n    [Number]: v => v,\r\n    [String]: v => v,\r\n    [Array]: v => (Array.isArray(v) ? RE(v) : typeof v === \"string\" ? JSON.parse(v) : RE([v])),\r\n    [Boolean]: v => (typeof v === \"boolean\" ? v : ![\"\", \"0\", \"false\", \"False\"].includes(v)),\r\n    [Object]: v => (typeof v === \"string\" ? JSON.parse(v) : v)\r\n};\r\n\r\n/**\r\n * The default values to be set when a type\r\n * conversion fails for the provided string value\r\n * the resulting value may be returned when a validation\r\n * fails an so it must be used carefully\r\n */\r\nconst TYPE_DEFAULTS = {\r\n    bytes: null,\r\n    unicode: null,\r\n    int: null,\r\n    float: null,\r\n    bool: false,\r\n    list: () => [],\r\n    dict: () => ({}),\r\n    object: () => ({})\r\n};\r\n\r\n/**\r\n * The various data types that are considered to be references\r\n * so that they are lazy loaded from the data source, these kind\r\n * of types should be compliant to a common interface so that they\r\n * may be used \"blindly\" from an external entity\r\n */\r\nconst TYPE_REFERENCES = [Reference, References];\r\n\r\n/**\r\n * The map that associates the various operators with the boolean\r\n * values that define if an insensitive base search should be used\r\n * instead of the \"typical\" sensitive search.\r\n */\r\nconst INSENSITIVE = {\r\n    likei: true,\r\n    llikei: true,\r\n    rlikei: true\r\n};\r\n\r\n/**\r\n * The map containing the mapping association between the\r\n * normalized version of the operators and the infra-structure\r\n * specific value for each of this operations, note that some\r\n * of the values don't have a valid mapping for this operations\r\n * the operator must be ignored and not used explicitly.\r\n */\r\nconst OPERATORS = {\r\n    eq: null,\r\n    equals: null,\r\n    ne: \"$ne\",\r\n    not_equals: \"$ne\",\r\n    in: \"$in\",\r\n    nin: \"$nin\",\r\n    not_in: \"$nin\",\r\n    like: \"$regex\",\r\n    likei: \"$regex\",\r\n    llike: \"$regex\",\r\n    llikei: \"$regex\",\r\n    rlike: \"$regex\",\r\n    rlikei: \"$regex\",\r\n    gt: \"$gt\",\r\n    greater: \"$gt\",\r\n    gte: \"$gte\",\r\n    greater_equal: \"$gte\",\r\n    lt: \"$lt\",\r\n    lesser: \"$lt\",\r\n    lte: \"$lte\",\r\n    lesser_equal: \"$lte\",\r\n    null: null,\r\n    is_null: null,\r\n    not_null: \"$ne\",\r\n    is_not_null: \"$ne\",\r\n    contains: \"$all\"\r\n};\r\n\r\n/**\r\n * Map that associates each of the normalized operations with\r\n * an inline function that together with the data type maps the\r\n * the base string based value into the target normalized value.\r\n */\r\nconst VALUE_METHODS = {\r\n    in: (v, t) => v.split(\";\").map(t),\r\n    not_in: (v, t) => v.split(\";\").map(t),\r\n    like: (v, t) => \"^.*\" + escapeStringRegexp(v) + \".*$\",\r\n    likei: (v, t) => \"^.*\" + escapeStringRegexp(v) + \".*$\",\r\n    llike: (v, t) => \"^.*\" + escapeStringRegexp(v) + \"$\",\r\n    llikei: (v, t) => \"^.*\" + escapeStringRegexp(v) + \"$\",\r\n    rlike: (v, t) => \"^\" + escapeStringRegexp(v) + \".*$\",\r\n    rlikei: (v, t) => \"^\" + escapeStringRegexp(v) + \".*$\",\r\n    null: (v, t) => null,\r\n    is_null: (v, t) => null,\r\n    not_null: (v, t) => null,\r\n    is_not_null: (v, t) => null,\r\n    contains: (v, t) => v.split(\";\").map(t)\r\n};\r\n\r\nclass Model {\r\n    constructor(options = {}) {\r\n        const fill = options.fill === undefined ? true : options.fill;\r\n        if (fill) this.constructor.fill(this);\r\n    }\r\n\r\n    static niw() {\r\n        return new this();\r\n    }\r\n\r\n    /**\r\n     * Fills the current model with the proper values so that\r\n     * no values are unset as this would violate the model definition\r\n     * integrity. This is required when retrieving an object(s) from\r\n     * the data source (as some of them may be incomplete).\r\n     *\r\n     * @param {Object} model The model that is going to have its unset\r\n     * attributes filled with \"default\" data, in case none is provided\r\n     * all of the attributes will be filled with \"default\" data.\r\n     * @param {Boolean} safe If the safe mode should be used for the fill\r\n     * operation meaning that under some conditions no unit fill\r\n     * operation is going to be applied (eg: retrieval operations).\r\n     */\r\n    static async fill(model = {}, safe = false) {\r\n        for (const [name, field] of Object.entries(this.schema)) {\r\n            if (model[name] !== undefined) continue;\r\n            if ([\"_id\"].includes(model[name])) continue;\r\n            const _private = field.private === undefined ? false : field.private;\r\n            const increment = field.increment === undefined ? false : field.increment;\r\n            if (_private && safe) continue;\r\n            if (increment) continue;\r\n            if (field.initial !== undefined) {\r\n                const initial = field.initial;\r\n                model[name] = initial;\r\n            } else {\r\n                const type = field.type || null;\r\n                let _default = typeD(type, null);\r\n                _default = type._default === undefined ? _default : type._default();\r\n                model[name] = _default;\r\n            }\r\n        }\r\n    }\r\n\r\n    static cast(name, value, safe = true) {\r\n        if (!this.schema[name]) return value;\r\n        if (value === null || value === undefined) return value;\r\n        const _definition = this.definitionN(name);\r\n        const _type = _definition.type || String;\r\n        const builder = BUILDERS[_type] || (v => new _type(v));\r\n        try {\r\n            return builder ? builder(value) : value;\r\n        } catch (err) {\r\n            if (!safe) throw err;\r\n            let _default = this.typeD[_type] || null;\r\n            _default = _type._default ? _type._default() : _default;\r\n            return _default;\r\n        }\r\n    }\r\n\r\n    static get eagers() {\r\n        return Object.entries(this.schema)\r\n            .filter(([name, field]) => field.eager)\r\n            .map(([name, field]) => name);\r\n    }\r\n\r\n    /**\r\n     * The name of the data source adapter that is going\r\n     * to be used to handle this model instance.\r\n     *\r\n     * @type {String}\r\n     */\r\n    static get adapter() {\r\n        return process.env.ADAPTER || \"mongo\";\r\n    }\r\n\r\n    async validate() {\r\n        const errors = [...this._validate()];\r\n        if (errors.length) {\r\n            throw new ValidationError(\r\n                `Invalid model: ${errors.map(err => String(err)).join(\", \")}`\r\n            );\r\n        }\r\n    }\r\n\r\n    async apply(model) {\r\n        await this.wrap(model);\r\n        return this;\r\n    }\r\n\r\n    async wrap(model) {\r\n        await this._wrap(model);\r\n        return this;\r\n    }\r\n\r\n    get isNew() {\r\n        return this._id === undefined;\r\n    }\r\n\r\n    get model() {\r\n        return this;\r\n    }\r\n\r\n    async jsonV() {\r\n        return this.model;\r\n    }\r\n\r\n    get string() {\r\n        return JSON.stringify(this.model);\r\n    }\r\n\r\n    /**\r\n     * Wraps the provided model object around the current instance, making\r\n     * sure that all of the elements are compliant with the schema.\r\n     *\r\n     * It should be possible to override the `_wrap` operation to implement\r\n     * a custom \"way\" of setting data into a model.\r\n     *\r\n     * @param {Object} model The model structure that is going to be used\r\n     * to wrap the current model object, meaning that all of its elements\r\n     * are going to be stored in the current object.\r\n     */\r\n    async _wrap(model) {\r\n        for (const key of Object.keys(this.constructor.schema)) {\r\n            const value = model[key];\r\n            if (value === undefined) continue;\r\n            this[key] = this.constructor.cast(key, value);\r\n        }\r\n        if (model._id !== undefined) this._id = model._id;\r\n    }\r\n\r\n    * _validate() {\r\n        for (const [name, value] of Object.entries(this.constructor.schema)) {\r\n            const validation = value.validation || false;\r\n            if (!validation) continue;\r\n            for (const callable of validation) {\r\n                try {\r\n                    callable(this[name]);\r\n                } catch (err) {\r\n                    yield err;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass ModelStore extends Model {\r\n    static _getAttrs(params, attrs) {\r\n        const _attrs = [];\r\n\r\n        attrs.forEach(([attr, value]) => {\r\n            if (params[attr] === undefined) {\r\n                _attrs.push(value);\r\n                return;\r\n            }\r\n\r\n            const _value = params[attr];\r\n            delete params[attr];\r\n            _attrs.push(_value);\r\n        });\r\n\r\n        return _attrs;\r\n    }\r\n\r\n    static async get(params = {}) {\r\n        /* eslint-disable no-unused-vars */\r\n        let [\r\n            fields,\r\n            eager,\r\n            eagerL,\r\n            map,\r\n            rules,\r\n            meta,\r\n            build,\r\n            fill,\r\n            resolveA,\r\n            skip,\r\n            limit,\r\n            sort,\r\n            raiseE\r\n        ] = this._getAttrs(params, [\r\n            [\"fields\", null],\r\n            [\"eager\", null],\r\n            [\"eagerL\", null],\r\n            [\"map\", false],\r\n            [\"rules\", true],\r\n            [\"meta\", false],\r\n            [\"build\", true],\r\n            [\"fill\", true],\r\n            [\"resolveA\", null],\r\n            [\"skip\", 0],\r\n            [\"limit\", 0],\r\n            [\"sort\", null],\r\n            [\"raiseE\", true]\r\n        ]);\r\n        /* eslint-enable no-unused-vars */\r\n        if (eagerL === null) eagerL = map;\r\n        if (eagerL) eager = this._eagerB(eager);\r\n\r\n        const sortObject = {};\r\n        if (sort) {\r\n            sort.forEach(([key, value]) => (sortObject[key] = value));\r\n        }\r\n\r\n        const found = await this.collection.findOne(params, this.fields, {\r\n            skip: skip,\r\n            limit: limit,\r\n            sort: sortObject\r\n        });\r\n\r\n        if (!found && raiseE) {\r\n            let message;\r\n            if (_isDevel()) {\r\n                message = `${this.name} not found for ${JSON.stringify(params)}`;\r\n            } else {\r\n                message = `${this.name} not found`;\r\n            }\r\n            throw new NotFoundError(message);\r\n        }\r\n        let model = found ? await new this().wrap(found) : found;\r\n        if (model) {\r\n            if (eager) model = await this._eager(model, eager, { map: map });\r\n        }\r\n        return model;\r\n    }\r\n\r\n    static async find(params = {}) {\r\n        /* eslint-disable no-unused-vars */\r\n        const [\r\n            fields,\r\n            eager,\r\n            eagerL,\r\n            map,\r\n            rules,\r\n            meta,\r\n            build,\r\n            fill,\r\n            resolveA,\r\n            skip,\r\n            limit,\r\n            sort,\r\n            raiseE\r\n        ] = this._getAttrs(params, [\r\n            [\"fields\", null],\r\n            [\"eager\", null],\r\n            [\"eagerL\", null],\r\n            [\"map\", false],\r\n            [\"rules\", true],\r\n            [\"meta\", false],\r\n            [\"build\", true],\r\n            [\"fill\", true],\r\n            [\"resolveA\", null],\r\n            [\"skip\", 0],\r\n            [\"limit\", 0],\r\n            [\"sort\", null],\r\n            [\"raiseE\", false]\r\n        ]);\r\n        /* eslint-enable no-unused-vars */\r\n\r\n        this._findS(params);\r\n        this._findD(params);\r\n\r\n        const sortObject = {};\r\n        if (sort) {\r\n            sort.forEach(([key, value]) => (sortObject[key] = value));\r\n        }\r\n\r\n        const found = await this.collection.find(params, this.fields, {\r\n            skip: skip,\r\n            limit: limit,\r\n            sort: sortObject\r\n        });\r\n\r\n        if (found.length === 0 && raiseE) {\r\n            let message;\r\n            if (_isDevel()) {\r\n                message = `${this.name} not found for ${JSON.stringify(params)}`;\r\n            } else {\r\n                message = `${this.name} not found`;\r\n            }\r\n            throw new NotFoundError(message);\r\n        }\r\n\r\n        const models = await Promise.all(found.map(v => new this().wrap(v)));\r\n        return models;\r\n    }\r\n\r\n    static async count(params = {}) {\r\n        let result = null;\r\n        if (Object.keys(params).length > 0) {\r\n            result = await this.collection.find(params);\r\n            result = result.length;\r\n        } else {\r\n            result = await this.collection.count();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static _findD(params) {\r\n        // retrieves the find definition into a local variable, then\r\n        // removes the find definition from the named arguments map\r\n        // so that it's not going to be erroneously used by the\r\n        // underlying find infra-structure\r\n        const findD = params.find_d;\r\n        delete params.find_d;\r\n\r\n        // in case the find definition is currently not defined in the\r\n        // named arguments map returns immediately as nothing is\r\n        // meant to be done on this method\r\n        if (!findD) return;\r\n\r\n        // tries to retrieve the value of the operator that is going\r\n        // to be used to \"join\" the multiple find parts (find values)\r\n        const findO = params.find_o;\r\n        delete params.find_o;\r\n\r\n        // verifies that the data type for the find definition is a\r\n        // valid sequence and in case its not converts it into one\r\n        // so that it may be used in sequence valid logic\r\n        const _findD = Array.isArray(findD) ? findD : [findD];\r\n\r\n        // iterates over all the filters defined in the filter definition\r\n        // so that they may be used to update the provided arguments with\r\n        // the filter defined in each of their lines\r\n        for (const filter of _findD) {\r\n            // in case the filter is not valid (unset or invalid) it's going\r\n            // to be ignored as no valid information is present\r\n            if (!filter) continue;\r\n\r\n            // splits the filter string into its three main components\r\n            // the name, operator and value, that are going to be processed\r\n            // as defined by the specification to create the filter\r\n            const result = filter.split(\":\", 3);\r\n            if (result.length === 2) result.push(null);\r\n\r\n            // unpacks the result into it's thee components name, operator\r\n            // and value to be used in the parsing of the filter\r\n            const [name, operator, value] = result;\r\n\r\n            // retrieves the definition for the filter attribute and uses\r\n            // it to retrieve it's target data type that is going to be\r\n            // used for the proper conversion, note that in case the base\r\n            // type resolution method exists it's used (recursive resolution)\r\n            const nameDefinition = this.definitionN(name);\r\n            const nameT = nameDefinition._btype || nameDefinition.type || String;\r\n\r\n            // determines if the current filter operation should be performed\r\n            // using a case insensitive based approach to the search, by default\r\n            // all of the operations are considered to be case sensitive\r\n            const insensitive = INSENSITIVE[operator] || false;\r\n\r\n            // retrieves the method that is going to be used for value mapping\r\n            // or conversion based on the current operator and then converts\r\n            // the operator into the domain specific operator\r\n            const valueMethod = VALUE_METHODS[operator];\r\n            const _operator = OPERATORS[operator] === undefined ? operator : OPERATORS[operator];\r\n\r\n            // in case there's a custom value mapped retrieved uses it to convert\r\n            // the string based value into the target specific value for the query\r\n            // otherwise uses the data type for the search field for value conversion\r\n            const _value = valueMethod ? valueMethod(value, nameT) : nameT(value);\r\n\r\n            // constructs the custom find value using a key and value map value\r\n            // in case the operator is defined otherwise (operator not defined)\r\n            // the value is used directly, then merges this find value into the\r\n            // current set of filters for the provided (keyword) arguments\r\n            let findV;\r\n            if (_operator) {\r\n                const obj = {};\r\n                obj[_operator] = _value;\r\n                findV = obj;\r\n            } else {\r\n                findV = _value;\r\n            }\r\n\r\n            if (insensitive) findV.$options = \"-i\";\r\n            this._filterMerge(name, findV, params, findO);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Working at a model map/dictionary level tries to resolve the\r\n     * relations described by the sequence of `.` separated names paths.\r\n     *\r\n     * Should be able to handle both instance and map associated eager\r\n     * loading relations.\r\n     *\r\n     * @param {Object} model The model map to be used as reference for the eager\r\n     * loading of relations.\r\n     * @param {Array} names The list of dot separated name paths to \"guide\" the\r\n     * loading of relations (references).\r\n     * @returns {Object} The resulting model with the required relations loaded.\r\n     */\r\n    static async _eager(model, names, kwargs = {}) {\r\n        // verifies if the provided model instance is a sequence and if\r\n        // that's the case runs the recursive eager loading of names and\r\n        // returns the resulting sequence to the caller method\r\n        const isList = Array.isArray(model);\r\n        if (isList) return Promise.all(model.map(_model => this._eager(_model, names, kwargs)));\r\n\r\n        // iterates over the complete set of names that are meant to be\r\n        // eager loaded from the model and runs the \"resolution\" process\r\n        // for each of them so that they are properly eager loaded\r\n        for (const name of names) {\r\n            let _model = model;\r\n            for (const part of name.split(\".\")) {\r\n                const isSequence = Array.isArray(_model);\r\n                if (isSequence) {\r\n                    _model = await Promise.all(_model.map(value => this._res(value, part, kwargs)));\r\n                } else _model = await this._res(_model, part, kwargs);\r\n                if (!_model) break;\r\n            }\r\n        }\r\n\r\n        // returns the resulting model to the caller method, most of the\r\n        // times this model should have not been touched\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Resolves a specific model part taking into account the multiple\r\n     * possible resolution strategies.\r\n     *\r\n     * Most of its logic will be associated with reference like types.\r\n     *\r\n     * This method will also (for map based resolution strategies) change\r\n     * the owner model, setting its references with the resolved maps, this\r\n     * is required as maps do not allow reference objects to exist.\r\n     *\r\n     * @param {Object} model The model map to be used in the resolution process.\r\n     * @param {String} part The name of the model's part to be resolved.\r\n     * @returns {Object} The resolved part that may be either a map or an object\r\n     * depending on the resolution strategy.\r\n     */\r\n    static async _res(model, part, kwargs = {}) {\r\n        // in case the provided is not valid returns it (no resolution is\r\n        // possible) otherwise gather the base value for resolution\r\n        if (!model) return model;\r\n        let value = model[part];\r\n\r\n        // check the data type of the requested name for resolution\r\n        // and in case it's not valid and not a reference returns it\r\n        // immediately, no resolution to be performed\r\n        const isReference = TYPE_REFERENCES.some(type => value instanceof type);\r\n        if (!value && !isReference) return value;\r\n\r\n        // in case the value is a reference type object then runs\r\n        // the resolve operation effectively resolving the values\r\n        // (this is considered a very expensive operation), notice\r\n        // that this operation is going to respect the map vs. instance\r\n        // kind of resolution process so the data type of the resulting\r\n        // value is going to depend on that\r\n        if (isReference) value = await value.resolve({ eagerL: true });\r\n\r\n        // in case the map resolution process was requested an explicit\r\n        // set of the resolved value is required (implicit resolution\r\n        // using `resolve()`) is not enough to ensure proper type structure\r\n        if (kwargs.map) model[part] = value;\r\n\r\n        // returns the \"final\" (possibly resolved) value to the caller method\r\n        // ready to be used for possible merging processes\r\n        return value;\r\n    }\r\n\r\n    static _findS(params) {\r\n        // tries to retrieve the find name value from the provided\r\n        // named arguments defaulting to an unset value otherwise\r\n        const findN = params.find_n;\r\n        delete params.find_n;\r\n\r\n        // retrieves the kind of insensitive strategy that is going\r\n        // to be used for the resolution of regular expressions,\r\n        // this should affect all the filters and so it should be\r\n        // used with some amount of care\r\n        const findI = params.find_i || false;\r\n        delete params.find_i;\r\n\r\n        // retrieves the kind of default operation to be performed\r\n        // this may be either: right, left or both and the default\r\n        // value is both so that the token is matched in case it\r\n        // appears anywhere in the search string\r\n        const findT = params.find_t || \"both\";\r\n        delete params.find_t;\r\n\r\n        // retrieves the find string into a local variable, then\r\n        // removes the find string from the named arguments map\r\n        // so that it's not going to be erroneously used by the\r\n        // underlying find infra-structure\r\n        const findS = params.find_s;\r\n        delete params.find_s;\r\n\r\n        // in case the find string is currently not defined in the\r\n        // named arguments map returns immediately as nothing is\r\n        // meant to be done on this method\r\n        if (!findS) return;\r\n\r\n        // retrieves the \"name\" of the attribute that is considered\r\n        // to be the default (representation) for the model in case\r\n        // there's none returns immediately, as it's not possible\r\n        // to proceed with the filter creation\r\n        const defaultName = findN || this.default; // TODO DEFAULT WORKS?\r\n        if (!defaultName) return;\r\n\r\n        // constructs the proper right and left parts of the regex\r\n        // that is going to be constructed for the matching of the\r\n        // value, this is achieved by checking the find type\r\n        const right = findT === \"right\" ? \"^\" : \"\";\r\n        const left = findT === \"left\" ? \"$\" : \"\";\r\n\r\n        // retrieves the definition for the default attribute and uses\r\n        // it to retrieve it's target data type, defaulting to the\r\n        // string type in case none is defined in the schema\r\n        const defaultT = this.definitionN(defaultName).type || String;\r\n\r\n        let findV;\r\n\r\n        try {\r\n            // in case the target date type for the default field is\r\n            // string the both sides wildcard regex is used for the\r\n            // search\r\n            if (defaultT === String) {\r\n                findV = {\r\n                    $regex: right + escapeStringRegexp(findS) + left,\r\n                    $options: findI ? \"-i\" : \"\"\r\n                };\r\n            } else {\r\n                findV = null;\r\n            }\r\n        } catch (err) {\r\n            // in case there's an error in the conversion for\r\n            // the target type value sets the search value as\r\n            // invalid (not going to be used in filter)\r\n            findV = null;\r\n        }\r\n\r\n        if (findV) this._filterMerge(defaultName, findV, params);\r\n    }\r\n\r\n    static get fields() {\r\n        return Object.keys(this.schema);\r\n    }\r\n\r\n    static get default() {\r\n        const defaultEntry = Object.entries(this.schema).find(\r\n            ([name, definition]) => definition.default\r\n        );\r\n        return defaultEntry ? defaultEntry[0] : null;\r\n    }\r\n\r\n    static definitionN(name) {\r\n        return this.schema[name] || {};\r\n    }\r\n\r\n    static _filterMerge(name, filter, params, operator = null) {\r\n        // retrieves a possible previous filter defined for the\r\n        // provided name in case it does exist must concatenate\r\n        // that previous value in a join statement according to\r\n        // the currently defined operator\r\n        const filterP = params[name];\r\n        if (filterP || operator) {\r\n            // defaults the operator for the join of the names to the\r\n            // value and then ensures that the value of the operator\r\n            // is within a valid range of values\r\n            const _operator = operator || \"$and\";\r\n            verify([\"$and\", \"$or\"].includes(_operator));\r\n\r\n            // retrieves the and references for the current arguments\r\n            // and appends the two filter values (current and previous)\r\n            // then deletes the current name reference in the arguments\r\n            // and updates the name value to the and value\r\n            const filterA = params[_operator] || [];\r\n\r\n            // builds the filter object assigned to the name of the\r\n            // variable and adds to the list of values\r\n            const _filter = {};\r\n            _filter[name] = filter;\r\n            filterA.push(_filter);\r\n\r\n            // in case there's a previous filter also adds it to the\r\n            // list of filter values\r\n            if (filterP) {\r\n                const _filterP = {};\r\n                _filterP[name] = filterP;\r\n                filterA.push(_filterP);\r\n            }\r\n\r\n            // updates the filter reference and updates the operator\r\n            // name (as expected)\r\n            filter = filterA;\r\n            delete params[name];\r\n            name = _operator;\r\n        }\r\n\r\n        // sets the currently defined filter structures in the keyword\r\n        // based arguments map for the currently defined name\r\n        params[name] = filter;\r\n    }\r\n\r\n    static get schema() {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    /**\r\n     * Safer version of the schema structure that filters\r\n     * some of the field attributes making it suitable to\r\n     * be used by some of the collection adapters.\r\n     */\r\n    static get schemaSafe() {\r\n        const schema = {};\r\n        for (const [key, value] of Object.entries(this.schema)) {\r\n            schema[key] = {\r\n                type: value.type || String,\r\n                index: value.index || false\r\n            };\r\n        }\r\n        return schema;\r\n    }\r\n\r\n    static get collection() {\r\n        if (this._collectionI) return this._collectionI;\r\n        this._collectionI = this._collection(this.dataOptions);\r\n        return this._collectionI;\r\n    }\r\n\r\n    static get idName() {\r\n        return \"id\";\r\n    }\r\n\r\n    static get dataOptions() {\r\n        return {\r\n            name: this.name,\r\n            schema: this.schemaSafe\r\n        };\r\n    }\r\n\r\n    static get increments() {\r\n        if (this._increments !== undefined) return this._increments;\r\n        const increments = [];\r\n\r\n        for (const [name, value] of Object.entries(this.schema)) {\r\n            const isIncrement = value.increment || false;\r\n            if (!isIncrement) continue;\r\n            increments.push(name);\r\n        }\r\n\r\n        this._increments = increments;\r\n        return increments;\r\n    }\r\n\r\n    static _collection(options) {\r\n        const adapter = this.adapter[0].toUpperCase() + this.adapter.slice(1);\r\n        return new collection[adapter + \"Collection\"](options);\r\n    }\r\n\r\n    static async _increment(name) {\r\n        const _name = this.name + \":\" + name;\r\n        const store = this._collection({\r\n            name: \"counters\",\r\n            schema: {\r\n                id: { type: String, index: true },\r\n                seq: { type: Number }\r\n            }\r\n        });\r\n        let result = await store.findOneAndUpdate(\r\n            {\r\n                id: _name\r\n            },\r\n            {\r\n                $inc: {\r\n                    seq: 1\r\n                }\r\n            },\r\n            {\r\n                new: true,\r\n                upsert: true\r\n            }\r\n        );\r\n        result = result || (await store.findOne({ id: _name }));\r\n        return result.seq;\r\n    }\r\n\r\n    static async _ensureMin(name, value) {\r\n        const _name = this.name + \":\" + name;\r\n        const store = this._collection({\r\n            name: \"counters\",\r\n            schema: {\r\n                id: { type: String },\r\n                seq: { type: Number }\r\n            }\r\n        });\r\n        let result = await store.findOneAndUpdate(\r\n            {\r\n                id: _name\r\n            },\r\n            {\r\n                $max: {\r\n                    seq: value\r\n                }\r\n            },\r\n            {\r\n                new: true,\r\n                upsert: true\r\n            }\r\n        );\r\n        result = result || (await store.findOne({ id: _name }));\r\n        return result.seq;\r\n    }\r\n\r\n    /**\r\n     * Builds the provided list of eager values, preparing them\r\n     * according to the current model rules.\r\n     *\r\n     * The composition process includes the extension of the provided\r\n     * sequence of eager values with the base ones defined in the\r\n     * model, if not handled correctly this is an expensive operation.\r\n     *\r\n     * @param {Array} eager The base sequence containing the various fields\r\n     * that should be eagerly loaded for the operation.\r\n     * @returns {Array} The \"final\" resolved array that may be used for the eager\r\n     * loaded operation performance.\r\n     */\r\n    static _eagerB(eager) {\r\n        eager = eager || [];\r\n        eager = Array.isArray(eager) ? eager : [eager];\r\n        eager.push(...this.eagers);\r\n        if (eager.length === 0) return eager;\r\n        eager = [...new Set(eager)];\r\n        return eager;\r\n    }\r\n\r\n    async save({\r\n        validate = true,\r\n        incrementA = undefined,\r\n        immutablesA = undefined,\r\n        preSave = true,\r\n        preCreate = true,\r\n        preUpdate = true,\r\n        postSave = true,\r\n        postCreate = true,\r\n        postUpdate = true,\r\n        beforeCallbacks = [],\r\n        afterCallbacks = []\r\n    } = {}) {\r\n        // in case the validate flag is set runs the model validation\r\n        // defined for the current model\r\n        if (validate) await this.validate();\r\n\r\n        // calls the complete set of event handlers for the current\r\n        // save operation, this should trigger changes in the model\r\n        if (preSave) await this.preSave();\r\n        if (preCreate) await this.preCreate();\r\n        if (preUpdate) await this.preUpdate();\r\n\r\n        // filters the values that are present in the current model\r\n        // so that only the valid ones are stored in, invalid values\r\n        // are going to be removed, note that if the operation is an\r\n        // update operation and the \"immutable rules\" also apply, the\r\n        // returned value is normalized meaning that for instance if\r\n        // any relation is loaded the reference value is returned instead\r\n        // of the loaded relation values (required for persistence)\r\n        let model = await this._filter({\r\n            incrementA: incrementA,\r\n            immutablesA: immutablesA,\r\n            normalize: true\r\n        });\r\n\r\n        // runs the lower layer integrity verifications that should raise\r\n        // exception in case there's a failure\r\n        await this.verify(model);\r\n\r\n        // calls the complete set of callbacks that should be called\r\n        // before the concrete data store save operation\r\n        for (const callback of beforeCallbacks) {\r\n            await callback(this, this.model);\r\n        }\r\n\r\n        // verifies if the current model is a new one or if instead\r\n        // represents an update to a previously stored model and create\r\n        // or update data accordingly\r\n        const isNew = this._id === undefined;\r\n        if (isNew) {\r\n            model = await this.constructor.collection.create(model);\r\n        } else {\r\n            const conditions = {};\r\n            conditions[this.constructor.idName] = this.identifier;\r\n            model = await this.constructor.collection.findOneAndUpdate(conditions, model);\r\n        }\r\n\r\n        // wraps the model object using the current instance\r\n        // effectively making the data available for consumers\r\n        this.wrap(model);\r\n\r\n        // calls the complete set of callbacks that should be called\r\n        // after the concrete data store save operation\r\n        for (const callback of afterCallbacks) {\r\n            await callback(this, this.model);\r\n        }\r\n\r\n        // calls the post save event handlers in order to be able to\r\n        // execute appropriate post operations\r\n        if (postSave) await this.postSave();\r\n        if (postCreate) await this.postCreate();\r\n        if (postUpdate) await this.postUpdate();\r\n\r\n        return this;\r\n    }\r\n\r\n    async delete({\r\n        preDelete = true,\r\n        postDelete = true,\r\n        beforeCallbacks = [],\r\n        afterCallbacks = []\r\n    } = {}) {\r\n        // calls the complete set of event handlers for the current\r\n        // delete operation, this should trigger changes in the model\r\n        if (preDelete) await this.preDelete();\r\n\r\n        // calls the complete set of callbacks that should be called\r\n        // before the concrete data store delete operation\r\n        for (const callback of beforeCallbacks) {\r\n            await callback(this, this.model);\r\n        }\r\n\r\n        // builds the set of conditions that rare going to be used for\r\n        // the concrete delete operation to be performed\r\n        const conditions = {};\r\n        conditions[this.constructor.idName] = this.identifier;\r\n        await this.constructor.collection.findOneAndDelete(conditions);\r\n\r\n        // calls the complete set of callbacks that should be called\r\n        // after the concrete data store delete operation\r\n        for (const callback of afterCallbacks) {\r\n            await callback(this, this.model);\r\n        }\r\n\r\n        // calls the complete set of event handlers for the current\r\n        // delete operation, this should trigger changes in the model\r\n        if (postDelete) await this.postDelete();\r\n\r\n        return this;\r\n    }\r\n\r\n    async advance(name, delta = 1) {\r\n        const conditions = {};\r\n        conditions[this.constructor.idName] = this.identifier;\r\n        const increments = {};\r\n        increments[name] = delta;\r\n        let value = await this.constructor.collection.findOneAndUpdate(\r\n            conditions,\r\n            {\r\n                $inc: increments\r\n            },\r\n            {\r\n                new: true\r\n            }\r\n        );\r\n        value = value || (await this.constructor.collection.find_one(conditions));\r\n        const _value = value[name];\r\n        this[name] = _value;\r\n        return _value;\r\n    }\r\n\r\n    async reload(params = {}) {\r\n        if (this.isNew) {\r\n            throw new OperationalError(\"Can't reload a new model entity\", 412);\r\n        }\r\n        const model = await this.constructor.get({ ...params, _id: this._id });\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Runs a series of assertions on the current model\r\n     * definition raising assertion errors in case there\r\n     * are issues with the internal structure of it.\r\n     *\r\n     * @param {Object} model The model that is going to\r\n     * be verified for a series of elements.\r\n     */\r\n    async verify(model) {\r\n        verify(\r\n            this.getIdentifier(model) !== undefined && this.getIdentifier(model) !== null,\r\n            \"The identifier must be defined before saving\",\r\n            400,\r\n            OperationalError\r\n        );\r\n        for (const [name, field] of Object.entries(this.constructor.schema)) {\r\n            verify(\r\n                !field.required || ![undefined, null].includes(model[name]),\r\n                `No value provided for mandatory field '${name}'`,\r\n                400,\r\n                OperationalError\r\n            );\r\n        }\r\n    }\r\n\r\n    async preSave() {}\r\n\r\n    async preCreate() {}\r\n\r\n    async preUpdate() {}\r\n\r\n    async preDelete() {}\r\n\r\n    async postSave() {}\r\n\r\n    async postCreate() {}\r\n\r\n    async postUpdate() {}\r\n\r\n    async postDelete() {}\r\n\r\n    async _filter({\r\n        incrementA = true,\r\n        immutablesA = true,\r\n        normalize = false,\r\n        resolve = false,\r\n        all = false,\r\n        evaluator = \"jsonV\"\r\n    } = {}) {\r\n        const model = {};\r\n\r\n        // iterates over each of the fields that are meant to have its value\r\n        // increment and performs the appropriate operation taking into account\r\n        // if the value is already populated or not\r\n        for (const name of this.constructor.increments) {\r\n            if (incrementA === false) continue;\r\n            const exists = this.model[name] !== undefined;\r\n            if (exists) {\r\n                model[name] = await this.constructor._ensureMin(name, this.model[name]);\r\n            } else {\r\n                model[name] = await this.constructor._increment(name);\r\n            }\r\n        }\r\n\r\n        // iterates over all the model items to filter the ones\r\n        // that are not valid for the current class context\r\n        await Promise.all(\r\n            Object.entries(this.model).map(async ([name, value]) => {\r\n                if (this.constructor.schema[name] === undefined) return;\r\n                // if (immutablesA && this.immutables[name] !== undefined) return;\r\n                model[name] = await this._evaluate(name, value, evaluator);\r\n            })\r\n        );\r\n\r\n        // in case the normalize flag is set must iterate over all\r\n        // items to try to normalize the values by calling the reference\r\n        // value this will returns the reference index value instead of\r\n        // the normal value that would prevent normalization\r\n        if (normalize) {\r\n            await Promise.all(\r\n                Object.entries(this.model).map(async ([name, value]) => {\r\n                    if (this.constructor.schema[name] === undefined) return;\r\n                    if (!value || !value.refV) return;\r\n                    model[name] = await value.refV();\r\n                })\r\n            );\r\n        }\r\n\r\n        // in case the resolution flag is set, it means that a recursive\r\n        // approach must be performed for the resolution of values that\r\n        // implement the map value (recursive resolution) method, this is\r\n        // a complex (and possible computational expensive) process that\r\n        // may imply access to the base data source\r\n        if (resolve) {\r\n            throw new NotImplementedError(\"'resolve' not implemented\");\r\n        }\r\n\r\n        // in case the all flag is set the extra fields (not present\r\n        // in definition) must also be used to populate the resulting\r\n        // (filtered) map so that it contains the complete set of values\r\n        // present in the base map of the current instance\r\n        if (all) {\r\n            throw new NotImplementedError(\"'all' not implemented\");\r\n        }\r\n\r\n        // returns the model containing the \"filtered\" items resulting\r\n        // from the validation of the items against the model class\r\n        return model;\r\n    }\r\n\r\n    async _evaluate(name, value, evaluator = \"jsonV\") {\r\n        // verifies if the current value is an iterable one in case\r\n        // it is runs the evaluate method for each of the values to\r\n        // try to resolve them into the proper representation, note\r\n        // that both base iterable values (lists and dictionaries) and\r\n        // objects that implement the evaluator method are not considered\r\n        // to be iterables and normal operation applies\r\n        let isIterable;\r\n        try {\r\n            isIterable = Boolean((value && value.items) || Array.isArray(value));\r\n        } catch (error) {\r\n            // AttributeErrors are tolerated since they might simply\r\n            // represent a missing \"items\" field when dealing with\r\n            // references\r\n            if (!(error instanceof AttributeError)) throw error;\r\n            isIterable = false;\r\n        }\r\n\r\n        const hasEvaluator = Boolean(\r\n            evaluator && (Array.isArray(value) ? value.length : value) && value[evaluator]\r\n        );\r\n        isIterable = isIterable && !hasEvaluator;\r\n        if (isIterable) {\r\n            const result = await Promise.all(\r\n                (value.items || value).map(item => this._evaluate(name, item, evaluator))\r\n            );\r\n            return result;\r\n        }\r\n\r\n        // verifies the current value's class is sub class of the model\r\n        // class and in case it's extracts the relation name from the\r\n        // value and sets it as the value in iteration\r\n        const isModel = value instanceof Model;\r\n        if (isModel) {\r\n            const meta = this.constructor.definitionN(name);\r\n            const type = meta.type || String;\r\n            const _name = type._name;\r\n            value = value[_name];\r\n        }\r\n\r\n        // iterates over all the values and retrieves the map value for\r\n        // each of them in case the value contains a map value retrieval\r\n        // method otherwise uses the normal value returning it to the caller\r\n        const method = hasEvaluator ? value[evaluator] : null;\r\n        value = method ? await method.bind(value)(false) : value;\r\n        return value;\r\n    }\r\n\r\n    getIdentifier(model) {\r\n        return model[this.constructor.idName];\r\n    }\r\n\r\n    get identifier() {\r\n        return this.getIdentifier(this.model);\r\n    }\r\n}\r\n\r\nclass ModelMemory extends ModelStore {\r\n    static get adapter() {\r\n        return \"memory\";\r\n    }\r\n\r\n    static get dataOptions() {\r\n        return Object.assign(super.dataOptions, { storage: this.storage });\r\n    }\r\n\r\n    static get storage() {\r\n        return MEMORY_STORAGE[this.name];\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieves the default (initial) value for the a certain\r\n * provided data type falling back to the provided default\r\n * value in case it's not possible to retrieve a new valid\r\n *  default for value for the type.\r\n *\r\n * The process of retrieval of the default value to a certain\r\n * type may include the calling of a lambda function to obtain\r\n * a new instance of the default value, this avoid the usage\r\n * of global shared structures for the default values, that\r\n * could cause extremely confusing situations.\r\n *\r\n * @param {Type} type The data type object for which to retrieve its\r\n * default value.\r\n * @param {Object} _default The default value to be returned in case it's\r\n * not possible to retrieve a better one.\r\n * @returns {Object} The \"final\" default value for the data type according\r\n * to the best possible strategy.\r\n */\r\nconst typeD = function(type, _default = null) {\r\n    if (TYPE_DEFAULTS[type] === undefined) return _default;\r\n    _default = TYPE_DEFAULTS[type];\r\n    if (typeof _default !== \"function\") return _default;\r\n    return _default();\r\n};\n\nconst ensureExpress = token => {\r\n    return (req, res, next) => {\r\n        ensurePermissions(token, req).catch(next).then(next);\r\n    };\r\n};\n\nconst yoniusRollup = function() {\r\n    return {\r\n        name: \"yonius\",\r\n        resolveId: function(importee) {\r\n            switch (importee) {\r\n                case \"fs\":\r\n                case \"node-fetch\":\r\n                    return importee;\r\n                default:\r\n                    return null;\r\n            }\r\n        },\r\n        load: function(id) {\r\n            switch (id) {\r\n                case \"fs\":\r\n                    return \"export const promises = {};\";\r\n                case \"node-fetch\":\r\n                    return \"export default fetch;\";\r\n                default:\r\n                    return null;\r\n            }\r\n        }\r\n    };\r\n};\n\nconst NAME = name;\r\nconst VERSION = version;\n\nexport { ALIAS, API, AttributeError, Collection, FIND_DEFAULTS, FIND_TYPES, FileTuple, INSENSITIVE, MixinBuilder, Model, ModelMemory, ModelStore, MongoCollection, NAME, NotFoundError, NotImplementedError, OAuth1API, OAuth2API, OAuthAPI, OPERATORS, Observable, OperationalError, Reference, References, SORT_MAP, VALUE_METHODS, VERSION, ValidationError, YoniusError, _castR, _isDevel, _isSecure, _isValid, absoluteUrl, all, buildGetAgent, camelToUnderscore, conf, confP, confS, destroyMongo, ensureExpress, ensurePermissions, eq, equal, escapeStringRegexp, expandUser, getEnv, getEnvObject, getObject, globals, gt, gte, hasPermission, initMongo, isEmail, isIn, isLower, isPrimitive, isRegex, isSimple, isUpper, isUrl, load, load$1 as loadConf, mix, notEmpty, patchAgent, pathExists, reference, references, register, request, sizeRoundUnit, stringEq, stringGt, stringLt, toTokensM, typeD, typeof_, underscoreToCamel, unload, unregister, urlEncode, verify, verifyEqual, verifyMany, verifyNotEqual, yoniusRollup };\n//# sourceMappingURL=yonius.esm.js.map\n","/**\r\n * Option type for access point search.\r\n */\r\nexport const ACCESS_POINT_SEARCH = \"64\";\r\n\r\n/**\r\n * Option type to sort by closest in search.\r\n */\r\nexport const CLOSEST_POINT_SEARCH = \"01\";\r\n\r\nexport const LocatorAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Finds the nearest UPS Access Point to a given address.\r\n         *\r\n         * @param {String} addressLine The address from where the distance is measured.\r\n         * @param {String} city The city from where the distance is measured.\r\n         * @param {String} postalCode The postalCode from where the distance is measured.\r\n         * @param {String} countryCode The countryCode from where the distance is measured.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async getNearestAccessPoint(addressLine, city, postalCode, countryCode, options = {}) {\r\n            const url = `${this.baseUrl}locations/${this.version}/search/availabilities/${ACCESS_POINT_SEARCH}`;\r\n            const payload = this._buildNearestAccessPointPayload(\r\n                addressLine,\r\n                city,\r\n                postalCode,\r\n                countryCode,\r\n                options\r\n            );\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: payload\r\n            });\r\n            return response;\r\n        }\r\n\r\n        _buildNearestAccessPointPayload(\r\n            addressLine,\r\n            city,\r\n            postalCode,\r\n            countryCode,\r\n            { consignee = null, locale = \"en_US\", metric = true, radius = 150 } = {}\r\n        ) {\r\n            const payload = {\r\n                LocatorRequest: {\r\n                    Request: {\r\n                        RequestAction: \"Locator\",\r\n                        RequestOption: ACCESS_POINT_SEARCH\r\n                    },\r\n                    OriginAddress: {\r\n                        AddressKeyFormat: {\r\n                            ConsigneeName: consignee,\r\n                            AddressLine: addressLine,\r\n                            PoliticalDivision2: city,\r\n                            PostcodePrimaryLow: postalCode,\r\n                            CountryCode: countryCode\r\n                        }\r\n                    },\r\n                    Translate: {\r\n                        Locale: locale\r\n                    },\r\n                    UnitOfMeasurement: { Code: metric ? \"KM\" : \"MI\" },\r\n                    SortCriteria: { SortType: CLOSEST_POINT_SEARCH }\r\n                }\r\n            };\r\n            return payload;\r\n        }\r\n    };\r\n","export const SMALL_PACKAGE_SHIPMENT_TYPE = \"1\";\r\nexport const FREIGHT_SHIPMENT_TYPE = \"2\";\r\n\r\nexport const AUTH_FORM_DOC_TYPE = \"001\";\r\nexport const INVOICE_DOC_TYPE = \"002\";\r\nexport const CERTIFICATE_ORIGIN_DOC_TYPE = \"003\";\r\nexport const EXPORT_ACCOMPANYING_DOC_TYPE = \"004\";\r\nexport const EXPORT_LICENSE_DOC_TYPE = \"005\";\r\nexport const IMPORT_PERMIT_DOC_TYPE = \"006\";\r\nexport const ONE_TIME_NAFTA_DOC_TYPE = \"007\";\r\nexport const OTHER_DOC_TYPE = \"008\";\r\nexport const POWER_ATTORNEY_DOC_TYPE = \"009\";\r\nexport const PACKING_LIST_DOC_TYPE = \"010\";\r\nexport const SED_DOC_TYPE = \"011\";\r\nexport const LETTER_INSTRUCTION_DOC_TYPE = \"012\";\r\nexport const DECLARATION_DOC_TYPE = \"013\";\r\n\r\nexport const PaperlessAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Uploads a document to the UPS servers.\r\n         * The uploaded document is returned and its ID can be\r\n         * used to associate a shipment with the document.\r\n         *\r\n         * @param {Object} payload The payload object according to the UPS API standards.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async createDocument(payload, options = {}) {\r\n            const url = `${this.baseUrl}paperlessdocuments/${this.version}/upload`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: { UploadRequest: payload }\r\n            });\r\n            return response;\r\n        }\r\n\r\n        /**\r\n         * Adds the already uploaded documents in the UPS servers to an\r\n         * existing shipment.\r\n         *\r\n         * @param {Object} payload The payload object according to the UPS API standards.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async addDocumentShipment(payload, options = {}) {\r\n            const url = `${this.baseUrl}paperlessdocuments/${this.version}/image`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: { PushToImageRepositoryRequest: payload }\r\n            });\r\n            return response;\r\n        }\r\n    };\r\n","export const PickupAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Schedules a pickup for a parcel.\r\n         *\r\n         * @param {Object} payload The payload object according to the UPS API standards.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async schedulePickup(payload, options = {}) {\r\n            const url = `${this.baseUrl}pickupcreation/${this.version}/pickup`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: { PickupCreationRequest: payload }\r\n            });\r\n            return response;\r\n        }\r\n    };\r\n","/*\r\n * The code representing an express shipment.\r\n */\r\nexport const EXPRESS_SERVICE_CODE = \"007\";\r\n\r\n/*\r\n * The code representing a standard shipment.\r\n */\r\nexport const STANDARD_SERVICE_CODE = \"011\";\r\n\r\n/*\r\n * The code representing a saver shipment.\r\n */\r\nexport const SAVER_SERVICE_CODE = \"065\";\r\n\r\n/*\r\n * The code representing a shipment transportation charges.\r\n */\r\nexport const TRANSPORTATION_CHARGE_TYPE = \"01\";\r\n\r\n/*\r\n * The code representing a shipment duties and taxes charges.\r\n */\r\nexport const DUTIES_CHARGE_TYPE = \"02\";\r\n\r\n/**\r\n * The code representing a customer box\r\n * package.\r\n */\r\nexport const CUSTOMER_BOX_PACKAGING_TYPE = \"02\";\r\n\r\n/**\r\n * The code representing a padded box\r\n * package.\r\n */\r\nexport const PAK_BOX_PACKAGING_TYPE = \"03\";\r\n\r\n/**\r\n * The code representing an express box\r\n * package.\r\n */\r\nexport const EXPRESS_BOX_PACKAGING_TYPE = \"21\";\r\n\r\n/**\r\n * Represents kilograms.\r\n */\r\nexport const KGS_TYPE = \"KGS\";\r\n\r\n/**\r\n * Represents pounds.\r\n */\r\nexport const LBS_TYPE = \"LBS\";\r\n\r\n/**\r\n * The code for a shipment to hold at an UPS Access Point.\r\n */\r\nexport const SHIPMENT_HOLD_ACCESS_POINT = \"01\";\r\n\r\n/**\r\n * The code for the PRL UPS return service.\r\n */\r\nexport const RETURN_PRL = \"9\";\r\n\r\n/**\r\n * The code to send an in transit email notification.\r\n */\r\nexport const NOTIFY_IN_TRANSIT = \"5\";\r\n\r\n/**\r\n * The code to send a package shipped email notification.\r\n */\r\nexport const NOTIFY_SHIP = \"6\";\r\n\r\n/**\r\n * The code to send exception email notifications.\r\n */\r\nexport const NOTIFY_EXCEPTION = \"7\";\r\n\r\n/**\r\n * The code to send a package delivered email notification.\r\n */\r\nexport const NOTIFY_DELIVERY = \"8\";\r\n\r\n/**\r\n * The code to send a delivery email notification when the package is at the Access Point.\r\n */\r\nexport const NOTIFY_ACCESS_POINT_DELIVERY = \"012\";\r\n\r\n/**\r\n * The code for a purchase order code value to\r\n * be used in reference number specification.\r\n */\r\nexport const PURCHASE_ORDER = \"PO\";\r\n\r\n/**\r\n * The code for a production code code value to\r\n * be used in reference number specification.\r\n */\r\nexport const PRODUCTION_CODE = \"PC\";\r\n\r\n/**\r\n * The code for reason for export.\r\n */\r\nexport const REASON_FOR_EXPORT = {\r\n    SALE: \"SALE\",\r\n    GIFT: \"GIFT\",\r\n    SAMPLE: \"SAMPLE\",\r\n    RETURN: \"RETURN\",\r\n    REPAIR: \"REPAIR\",\r\n    INTERCOMPANY_DATA: \"INTERCOMPANYDATA\",\r\n    ANY: \"Any other reason\"\r\n};\r\n\r\n/**\r\n * The code for form types to be used in international shipping.\r\n */\r\nexport const INTERNATIONAL_FORM_TYPE = {\r\n    USER_CREATED_FORM: \"07\",\r\n    FULL_INVOICE: \"01\"\r\n};\r\n\r\nexport const ShipmentAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Creates a shipment and associated UPS waybill.\r\n         *\r\n         * @param {Object} payload The payload object according to the UPS API standards.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async createShipment(payload, options = {}) {\r\n            const url = `${this.baseUrl}shipments/${this.version}/ship`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: { ShipmentRequest: payload }\r\n            });\r\n            return response;\r\n        }\r\n\r\n        /**\r\n         * Cancels (voids) an existing shipment and associated UPS waybill.\r\n         *\r\n         * @param {String} trackingNumber The tracking number of the shipment/waybill.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async cancelShipment(trackingNumber, options = {}) {\r\n            const url = `${this.baseUrl}shipments/${this.version}/void/cancel/${trackingNumber}`;\r\n            const response = await this.delete(url, options);\r\n            return response;\r\n        }\r\n\r\n        /**\r\n         * Gets the waybill for an existing shipment.\r\n         *\r\n         * @param {String} trackingNumber The tracking number of the shipment/waybill.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async getWaybill(trackingNumber, { format = \"pdf\", ...options } = {}) {\r\n            const url = `${this.baseUrl}labels/${this.version}/recovery`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: {\r\n                    LabelRecoveryRequest: {\r\n                        TrackingNumber: String(trackingNumber),\r\n                        LabelSpecification: {\r\n                            LabelImageFormat: {\r\n                                Code: format.toUpperCase()\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            return response;\r\n        }\r\n    };\r\n","/**\r\n * Shipment was picked up.\r\n */\r\nexport const STATUS_PICKUP = \"P\";\r\n\r\n/**\r\n * Shipment out for delivery.\r\n */\r\nexport const STATUS_OUT_FOR_DELIVERY = \"O\";\r\n\r\n/**\r\n * Shipment in transit.\r\n */\r\nexport const STATUS_IN_TRANSIT = \"I\";\r\n\r\n/**\r\n * Shipment exception.\r\n */\r\nexport const STATUS_EXCEPTION = \"X\";\r\n\r\n/**\r\n * Shipment delivered.\r\n */\r\nexport const STATUS_DELIVERED = \"D\";\r\n\r\n/**\r\n * Shipment returned to shipper.\r\n */\r\nexport const STATUS_RETURNED = \"RS\";\r\n\r\nexport const TrackingAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Gets the tracking information for an existing shipment.\r\n         *\r\n         * @param {String} trackingNumber The tracking number of the shipment/waybill.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async getTrackingDetails(trackingNumber, options = {}) {\r\n            const url = `${this.baseUrl}track/${this.version}/details/${trackingNumber}`;\r\n            const response = await this.get(url, options);\r\n            return response;\r\n        }\r\n\r\n        /**\r\n         * Gets the tracking URL given a tracking number.\r\n         *\r\n         * @param {String} trackingNumber The tracking number of the shipment/waybill.\r\n         * @returns {String} The tracking URL.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        getTrackingUrl(trackingNumber) {\r\n            return `https://www.ups.com/track?InquiryNumber1=${trackingNumber}`;\r\n        }\r\n    };\r\n","import { API as BaseAPI, OperationalError, mix, load, conf } from \"yonius\";\r\n\r\nimport { LocatorAPI } from \"./locator\";\r\nimport { PaperlessAPI } from \"./paperless\";\r\nimport { PickupAPI } from \"./pickup\";\r\nimport { ShipmentAPI } from \"./shipment\";\r\nimport { TrackingAPI } from \"./tracking\";\r\n\r\n/**\r\n * The base auth URL used for the OAuth token request.\r\n */\r\nconst AUTH_URL = \"https://onlinetools.ups.com/\";\r\n\r\n/**\r\n * The base URL used for API requests.\r\n */\r\nconst BASE_URL = \"https://onlinetools.ups.com/api/\";\r\n\r\n/**\r\n * The version of the API to use.\r\n */\r\nconst API_VERSION = \"v1\";\r\n\r\n/**\r\n * The application grant type to obtain the token.\r\n */\r\nconst GRANT_TYPE = \"client_credentials\";\r\n\r\nexport class API extends mix(BaseAPI).with(\r\n    LocatorAPI,\r\n    PaperlessAPI,\r\n    PickupAPI,\r\n    ShipmentAPI,\r\n    TrackingAPI\r\n) {\r\n    constructor(kwargs = {}) {\r\n        super(kwargs);\r\n\r\n        this.authUrl = conf(\"UPS_AUTH_URL\", AUTH_URL);\r\n        this.baseUrl = conf(\"UPS_BASE_URL\", BASE_URL);\r\n        this.version = conf(\"UPS_API_VERSION\", API_VERSION);\r\n        this.clientId = conf(\"UPS_CLIENT_ID\", null);\r\n        this.clientSecret = conf(\"UPS_CLIENT_SECRET\", null);\r\n        this.grantType = conf(\"UPS_GRANT_TYPE\", GRANT_TYPE);\r\n        this.token = conf(\"UPS_TOKEN\", null);\r\n        this.transactionSrc = conf(\"UPS_TRANSACTION_SRC\", null);\r\n\r\n        this.authUrl = kwargs.authUrl === undefined ? this.authUrl : kwargs.authUrl;\r\n        this.baseUrl = kwargs.baseUrl === undefined ? this.baseUrl : kwargs.baseUrl;\r\n        this.version = kwargs.version === undefined ? this.version : kwargs.version;\r\n        this.clientId = kwargs.clientId === undefined ? this.clientId : kwargs.clientId;\r\n        this.clientSecret =\r\n            kwargs.clientSecret === undefined ? this.clientSecret : kwargs.clientSecret;\r\n        this.token = kwargs.token === undefined ? this.token : kwargs.token;\r\n        this.transactionSrc =\r\n            kwargs.transactionSrc === undefined ? this.transactionSrc : kwargs.transactionSrc;\r\n    }\r\n\r\n    static async load() {\r\n        await load();\r\n    }\r\n\r\n    async build(method, url, options = {}) {\r\n        await super.build(method, url, options);\r\n\r\n        if (this.token) options.headers.Authorization = this._bearerAuth();\r\n\r\n        const transactionSrc = options.headers.transactionSrc || this.transactionSrc;\r\n        if (transactionSrc) options.headers.transactionSrc = transactionSrc;\r\n\r\n        // add some fields to the header that UPS requires\r\n        if(!options.headers.transId) options.headers.transId = this.makeid(14)\r\n        if(!options.headers.transactionSrc) options.headers.transactionSrc = 'DEFAULT'\r\n        \r\n    }\r\n    \r\n    makeid(len){\r\n        var result           = '';\r\n        var char       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        var charLen = char.length;\r\n        for ( var i = 0; i < len; i++ ) {\r\n            result += char.charAt(Math.floor(Math.random() * \r\n            charLen));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    async authCallback(params, headers) {\r\n        // forces the refetch of the authorization\r\n        // token from the auth API\r\n        this.token = null;\r\n        await this.getToken();\r\n    }\r\n\r\n    async getToken() {\r\n        if (this.token) return this.token;\r\n\r\n        const url = `${this.authUrl}security/${this.version}/oauth/token`;\r\n        const data = `grant_type=${this.grantType}`;\r\n        const options = {\r\n            headers: {\r\n                Authorization: this._basicAuth()\r\n            },\r\n            data: data,\r\n            mime: \"application/x-www-form-urlencoded\"\r\n        };\r\n\r\n        const contents = await this.post(url, options);\r\n        this.token = contents.access_token;\r\n\r\n        return this.token;\r\n    }\r\n\r\n    async _handleResponse(response, errorMessage = \"Problem in request\") {\r\n        const result = await this._getResult(response);\r\n        if (!response.ok) {\r\n            let error = null;\r\n            try {\r\n                error = JSON.stringify(result);\r\n            } catch {\r\n                error = errorMessage;\r\n            }\r\n            throw new OperationalError(error, response.status || 500);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Obtains the response object from the provided response making sure that the\r\n     * content type is respected when doing so.\r\n     *\r\n     * @param {Response} response The HTTP response resulting from the request\r\n     * made by the API client\r\n     * @returns {Object|String|Blob} The parsed result value for the provided\r\n     * response object taking into account the content type of it.\r\n     */\r\n    async _getResult(response) {\r\n        let result = null;\r\n        if (\r\n            response.headers.get(\"content-type\") &&\r\n            response.headers.get(\"content-type\").toLowerCase().startsWith(\"application/json\")\r\n        ) {\r\n            result = await response.json();\r\n        } else if (\r\n            response.headers.get(\"content-type\") &&\r\n            response.headers.get(\"content-type\").toLowerCase().startsWith(\"text/\")\r\n        ) {\r\n            result = await response.text();\r\n        } else {\r\n            result = await response.blob();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    _basicAuth() {\r\n        const auth = Buffer.from(`${this.clientId}:${this.clientSecret}`).toString(\"base64\");\r\n        return `Basic ${auth}`;\r\n    }\r\n\r\n    _bearerAuth() {\r\n        return `Bearer ${this.token}`;\r\n    }\r\n}\r\n"],"names":["API","BaseAPI"],"mappings":"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"}