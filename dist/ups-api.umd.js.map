{"version":3,"file":"ups-api.umd.js","sources":["../node_modules/rollup-plugin-node-polyfills/polyfills/global.js","../node_modules/rollup-plugin-node-polyfills/polyfills/process-es6.js","../fs","../node_modules/rollup-plugin-node-polyfills/polyfills/path.js","../node-fetch","../node_modules/yonius/dist/yonius.esm.js","../js/locator.js","../js/paperless.js","../js/pickup.js","../js/shipment.js","../js/tracking.js","../js/base.js"],"sourcesContent":["export default (typeof global !== \"undefined\" ? global :\n  typeof self !== \"undefined\" ? self :\n  typeof window !== \"undefined\" ? window : {});","// shim for using process in browser\n// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n}\nif (typeof global.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n}\n\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\nfunction nextTick(fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nvar title = 'browser';\nvar platform = 'browser';\nvar browser = true;\nvar env = {};\nvar argv = [];\nvar version = ''; // empty string to avoid regexp issues\nvar versions = {};\nvar release = {};\nvar config = {};\n\nfunction noop() {}\n\nvar on = noop;\nvar addListener = noop;\nvar once = noop;\nvar off = noop;\nvar removeListener = noop;\nvar removeAllListeners = noop;\nvar emit = noop;\n\nfunction binding(name) {\n    throw new Error('process.binding is not supported');\n}\n\nfunction cwd () { return '/' }\nfunction chdir (dir) {\n    throw new Error('process.chdir is not supported');\n}function umask() { return 0; }\n\n// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance = global.performance || {};\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime() };\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp){\n  var clocktime = performanceNow.call(performance)*1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor((clocktime%1)*1e9);\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n    if (nanoseconds<0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [seconds,nanoseconds]\n}\n\nvar startTime = new Date();\nfunction uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;\n}\n\nvar browser$1 = {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime\n};\n\nexport default browser$1;\nexport { addListener, argv, binding, browser, chdir, config, cwd, emit, env, hrtime, nextTick, off, on, once, platform, release, removeAllListeners, removeListener, title, umask, uptime, version, versions };\n","export const promises = {};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexport function resolve() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : '/';\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexport function normalize(path) {\n  var isPathAbsolute = isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isPathAbsolute).join('/');\n\n  if (!path && !isPathAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isPathAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexport function isAbsolute(path) {\n  return path.charAt(0) === '/';\n}\n\n// posix version\nexport function join() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n}\n\n\n// path.relative(from, to)\n// posix version\nexport function relative(from, to) {\n  from = resolve(from).substr(1);\n  to = resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n}\n\nexport var sep = '/';\nexport var delimiter = ':';\n\nexport function dirname(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\nexport function basename(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n}\n\n\nexport function extname(path) {\n  return splitPath(path)[3];\n}\nexport default {\n  extname: extname,\n  basename: basename,\n  dirname: dirname,\n  sep: sep,\n  delimiter: delimiter,\n  relative: relative,\n  join: join,\n  isAbsolute: isAbsolute,\n  normalize: normalize,\n  resolve: resolve\n};\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ?\n    function (str, start, len) { return str.substr(start, len) } :\n    function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","export default fetch;","/**\n * Yonius 0.11.7.\n *\n * Copyright (c) 2008-2022 Hive Solutions Lda.\n *\n * This source code is licensed under the Apache 2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as fs from 'fs';\nimport { join, normalize, resolve, dirname } from 'path';\nimport { env } from 'process';\nimport fetch from 'node-fetch';\n\nvar name = \"yonius\";\nvar version = \"0.11.7\";\n\nclass Observable {\r\n    constructor() {\r\n        this.callbacks = {};\r\n    }\r\n\r\n    bind(event, callback) {\r\n        const callbacks = this.callbacks[event] || [];\r\n        callbacks.push(callback);\r\n        this.callbacks[event] = callbacks;\r\n        return callback;\r\n    }\r\n\r\n    unbind(event, callback) {\r\n        const callbacks = this.callbacks[event] || [];\r\n        if (!callback) {\r\n            delete this.callbacks[event];\r\n            return;\r\n        }\r\n\r\n        const index = callbacks.indexOf(callback);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        callbacks.splice(index, 1);\r\n        this.callbacks[event] = callbacks;\r\n    }\r\n\r\n    trigger(event) {\r\n        const callbacks = this.callbacks[event] || [];\r\n        const results = [];\r\n        for (const callback of callbacks) {\r\n            const result = callback.apply(this, Array.prototype.slice.call(arguments, 1));\r\n            result !== undefined && result !== null && results.push(result);\r\n        }\r\n        return Promise.all(results);\r\n    }\r\n}\n\nconst verify = function(\r\n    condition,\r\n    message = null,\r\n    code = null,\r\n    exception = null,\r\n    kwargs = {},\r\n    safeKeys = [\"message\"]\r\n) {\r\n    if (condition) return;\r\n    message = message || \"Verification failed\";\r\n    const Exception = exception || Error;\r\n    kwargs = Object.assign({}, kwargs);\r\n    if (message !== null && message !== undefined) kwargs.message = message;\r\n    if (code !== null && message !== undefined) kwargs.code = code;\r\n    const throwable = new Exception(kwargs.message || undefined);\r\n    throwable.kwargs = kwargs;\r\n    for (const [key, value] of Object.entries(kwargs)) {\r\n        if (safeKeys.includes(key) && throwable[key] !== undefined) {\r\n            continue;\r\n        }\r\n        throwable[key] = value;\r\n    }\r\n    throw throwable;\r\n};\r\n\r\nconst verifyEqual = function(\r\n    first,\r\n    second,\r\n    message = null,\r\n    code = null,\r\n    exception = null,\r\n    kwargs = {}\r\n) {\r\n    message = message || `Expected ${first} got ${second}`;\r\n    return this.verify(first === second, message, code, exception, kwargs);\r\n};\r\n\r\nconst verifyNotEqual = function(\r\n    first,\r\n    second,\r\n    message = null,\r\n    code = null,\r\n    exception = null,\r\n    kwargs = {}\r\n) {\r\n    message = message || `Expected ${first} not equal to ${second}`;\r\n    return this.verify(first !== second, message, code, exception, kwargs);\r\n};\r\n\r\nconst verifyMany = function(\r\n    sequence,\r\n    message = null,\r\n    code = null,\r\n    exception = null,\r\n    kwargs = {}\r\n) {\r\n    sequence.forEach(element => {\r\n        verify(element, message, code, exception, kwargs);\r\n    });\r\n};\n\nlet HOME_DIR = null;\r\n\r\nconst pathExists = async function(path) {\r\n    try {\r\n        await fs.promises.access(path);\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\n\r\nconst expandUser = function(path) {\r\n    if (!path) return path;\r\n    if (path === \"~\") return _homeDir();\r\n    if (path.slice(0, 2) !== \"~/\") return path;\r\n    return join(HOME_DIR, path.slice(2));\r\n};\r\n\r\nconst getEnv = function(name) {\r\n    // eslint-disable-next-line no-undef\r\n    if (typeof Deno !== \"undefined\") return Deno.env.get(name);\r\n    return env[name];\r\n};\r\n\r\nconst getEnvObject = function() {\r\n    // eslint-disable-next-line no-undef\r\n    if (typeof Deno !== \"undefined\") return Deno.env.toObject();\r\n    return env;\r\n};\r\n\r\nconst _homeDir = function() {\r\n    if (HOME_DIR !== null) return HOME_DIR;\r\n    const isWindows = Boolean(typeof process !== \"undefined\" && process.platform === \"win32\");\r\n    HOME_DIR = getEnv(isWindows ? \"USERPROFILE\" : \"HOME\") || \"/\";\r\n    return HOME_DIR;\r\n};\n\nconst FILE_NAME = \"yonius.json\";\r\n\r\nconst HOME_FILE = \"~/.home\";\r\n\r\nconst IMPORT_NAMES = [\"$import\", \"$include\", \"$IMPORT\", \"$INCLUDE\"];\r\n\r\nconst CASTS = {\r\n    int: v => (typeof v === \"number\" ? v : parseInt(v)),\r\n    float: v => (typeof v === \"number\" ? v : parseFloat(v)),\r\n    bool: v => (typeof v === \"boolean\" ? v : [\"1\", \"true\", \"True\"].includes(v)),\r\n    list: v => (Array.isArray(v) ? v : v.split(\";\")),\r\n    tuple: v => (Array.isArray(v) ? v : v.split(\";\"))\r\n};\r\n\r\nconst globals =\r\n    typeof global === \"undefined\"\r\n        ? typeof window === \"undefined\"\r\n            ? typeof self === \"undefined\"\r\n                ? {}\r\n                : self\r\n            : window\r\n        : global;\r\n\r\nglobals.CONFIGS = globals.CONFIGS === undefined ? {} : globals.CONFIGS;\r\n\r\nglobals.CONFIG_F = globals.CONFIG_F === undefined ? [] : globals.CONFIG_F;\r\n\r\nglobals.HOMES = globals.HOMES === undefined ? [] : globals.HOMES;\r\n\r\nglobals.LOADED = globals.LOADED === undefined ? false : globals.LOADED;\r\n\r\nconst conf = function(name, fallback = undefined, cast = null, ctx = null) {\r\n    const configs = ctx ? ctx.configs : globals.CONFIGS;\r\n    cast = _castR(cast);\r\n    let value = configs[name] === undefined ? fallback : configs[name];\r\n    if (cast && value !== undefined && value !== null) value = cast(value);\r\n    return value;\r\n};\r\n\r\nconst confP = async function(name, fallback = undefined, cast = null, ctx = null) {\r\n    await load$1();\r\n    return conf(name, fallback, cast, ctx);\r\n};\r\n\r\nconst confS = function(name, value, ctx = null) {\r\n    const configs = ctx ? ctx.configs : globals.CONFIGS;\r\n    configs[name] = value;\r\n};\r\n\r\nconst load$1 = async function(\r\n    names = [FILE_NAME],\r\n    path = null,\r\n    encoding = \"utf-8\",\r\n    force = false,\r\n    ctx = null\r\n) {\r\n    if (globals.LOADED && !force) return;\r\n    let paths = [];\r\n    const homes = await getHomes();\r\n    for (const home of homes) {\r\n        paths = paths.concat([join(home), join(home, \".config\")]);\r\n    }\r\n    paths.push(path);\r\n    for (const path of paths) {\r\n        for (const name of names) {\r\n            await loadFile(name, path, encoding, ctx);\r\n        }\r\n    }\r\n    await loadEnv(ctx);\r\n    globals.LOADED = true;\r\n};\r\n\r\nconst loadFile = async function(\r\n    name = FILE_NAME,\r\n    path = null,\r\n    encoding = \"utf-8\",\r\n    ctx = null\r\n) {\r\n    const configs = ctx ? ctx.configs : globals.CONFIGS;\r\n    const configF = ctx ? ctx.configF : globals.CONFIG_F;\r\n\r\n    let key;\r\n    let value;\r\n    let exists;\r\n    let filePath;\r\n\r\n    if (path) path = normalize(path);\r\n    if (path) filePath = join(path, name);\r\n    else filePath = name;\r\n\r\n    filePath = resolve(filePath);\r\n    filePath = normalize(filePath);\r\n    const basePath = dirname(filePath);\r\n\r\n    exists = await pathExists(filePath);\r\n    if (!exists) return;\r\n\r\n    exists = configF.includes(filePath);\r\n    if (exists) configF.splice(configF.indexOf(filePath), 1);\r\n    configF.push(filePath);\r\n\r\n    const data = await fs.promises.readFile(filePath, { encoding: encoding });\r\n    const dataJ = JSON.parse(data);\r\n\r\n    await _loadIncludes(basePath, dataJ, encoding);\r\n\r\n    for ([key, value] of Object.entries(dataJ)) {\r\n        if (!_isValid(key)) continue;\r\n        configs[key] = value;\r\n    }\r\n};\r\n\r\nconst loadEnv = async function(ctx = null) {\r\n    const env = getEnvObject();\r\n    const configs = ctx ? ctx.configs : globals.CONFIGS;\r\n    if (env === undefined || env === null) return;\r\n    Object.entries(env).forEach(function([key, value]) {\r\n        configs[key] = value;\r\n    });\r\n};\r\n\r\nconst getHomes = async function(\r\n    filePath = HOME_FILE,\r\n    fallback = \"~\",\r\n    encoding = \"utf-8\",\r\n    forceDefault = false\r\n) {\r\n    if (globals.HOMES.length > 0) return globals.HOMES;\r\n\r\n    const env = getEnvObject();\r\n\r\n    globals.HOMES = env.HOMES === undefined ? null : env.HOMES;\r\n    globals.HOMES = globals.HOMES ? globals.HOMES.split(\";\") : globals.HOMES;\r\n    if (globals.HOMES !== null) return globals.HOMES;\r\n\r\n    fallback = expandUser(fallback);\r\n    fallback = normalize(fallback);\r\n    globals.HOMES = [fallback];\r\n\r\n    filePath = expandUser(filePath);\r\n    filePath = normalize(filePath);\r\n    const exists = await pathExists(filePath);\r\n    if (!exists) return globals.HOMES;\r\n\r\n    if (!forceDefault) globals.HOMES.splice(0, globals.HOMES.length);\r\n\r\n    let data = await fs.promises.readFile(filePath, { encoding: encoding });\r\n    data = data.trim();\r\n\r\n    let paths = data.split(/\\r?\\n/);\r\n    paths = paths.map(v => v.trim());\r\n\r\n    for (let path of paths) {\r\n        path = path.trim();\r\n        if (!path) continue;\r\n        path = expandUser(path);\r\n        path = normalize(path);\r\n        globals.HOMES.push(path);\r\n    }\r\n\r\n    return globals.HOMES;\r\n};\r\n\r\nconst _castR = function(cast) {\r\n    return CASTS[cast] === undefined ? cast : CASTS[cast];\r\n};\r\n\r\nconst _loadIncludes = async function(basePath, config, encoding = \"utf-8\") {\r\n    let includes = [];\r\n\r\n    for (const alias of IMPORT_NAMES) {\r\n        includes = config[alias] === undefined ? includes : config[alias];\r\n    }\r\n\r\n    if (typeof includes === \"string\") {\r\n        includes = includes.split(\";\");\r\n    }\r\n\r\n    for (const include of includes) {\r\n        await loadFile(include, basePath, encoding);\r\n    }\r\n};\r\n\r\nconst _isValid = function(key) {\r\n    if (IMPORT_NAMES.includes(key)) return false;\r\n    return true;\r\n};\r\n\r\nconst _isDevel = function() {\r\n    return [\"DEBUG\"].includes(conf(\"LEVEL\", \"INFO\"));\r\n};\r\n\r\nconst _isSecure = function() {\r\n    return conf(\"SECURE\", true, \"bool\");\r\n};\n\n/**\r\n * The map containing the various attribute alias between the normalized\r\n * manned and the Yonius manner.\r\n */\r\nconst ALIAS = {\r\n    context: \"find_d\",\r\n    filters: \"find_d\",\r\n    \"filters[]\": \"find_d\",\r\n    filter_def: \"find_d\",\r\n    filter_string: \"find_s\",\r\n    filter_name: \"find_n\",\r\n    filter_operator: \"find_o\",\r\n    insensitive: \"find_i\",\r\n    order: \"sort\",\r\n    offset: \"skip\",\r\n    start_record: \"skip\",\r\n    number_records: \"limit\"\r\n};\r\n\r\n/**\r\n * The map associating the various find fields with their respective\r\n * types, note that in case a special conversion operation is required\r\n * the associated value may represent a conversion function instead.\r\n */\r\nconst FIND_TYPES = {\r\n    skip: v => parseInt(v),\r\n    limit: v => Math.max(0, parseInt(v)),\r\n    find_s: v => v,\r\n    find_d: v => (Array.isArray(v) ? v : [v]),\r\n    find_i: v => Boolean(v),\r\n    find_t: v => v,\r\n    find_n: v => v,\r\n    find_o: v => v,\r\n    sort: v => _toSort(v),\r\n    meta: v => Boolean(v),\r\n    fields: v => v\r\n};\r\n\r\n/**\r\n * The map that defines the various default values for a series of\r\n * find related attributes.\r\n */\r\nconst FIND_DEFAULTS = { limit: 10 };\r\n\r\n/**\r\n * The map associating the normalized (text) way of representing sorting\r\n * with the current infra-structure number way of representing the same\r\n * information.\r\n */\r\nconst SORT_MAP = {\r\n    1: 1,\r\n    \"-1\": -1,\r\n    ascending: 1,\r\n    descending: -1\r\n};\r\n\r\nconst getObject = function(params = {}, options = {}) {\r\n    const { alias = false, page = false, find = false, norm = true } = options;\r\n    let result = params;\r\n\r\n    // in case the alias flag is set tries to resolve the attribute alias and\r\n    // in case the find types are set converts the find based attributes using\r\n    // the currently defined mapping map\r\n    if (alias) result = _resolveAlias(result);\r\n    if (page) result = _pageTypes(result);\r\n    if (find) {\r\n        result = _findTypes(result);\r\n        result = _findDefaults(result, options);\r\n    }\r\n\r\n    // in case the normalization flag is set runs the normalization of the\r\n    // provided object so that sequences are properly handled as defined in\r\n    // the specification (this allows multiple references)\r\n    if (norm) result = _normParams(result);\r\n\r\n    // returns the constructed object to the caller method this object\r\n    // should be a structured representation of the data in the request\r\n    return result;\r\n};\r\n\r\nconst _resolveAlias = function(params) {\r\n    const result = {};\r\n    Object.entries(params).forEach(([key, value]) => {\r\n        result[ALIAS[key] || key] = value;\r\n    });\r\n    return result;\r\n};\r\n\r\nconst _pageTypes = function(params, defaultSize = 50) {\r\n    const result = Object.assign({}, params);\r\n\r\n    const page = parseInt(params.page || 1);\r\n    const size = parseInt(params.size || defaultSize);\r\n    const offset = page - 1;\r\n    result.skip = offset * size;\r\n    result.limit = size;\r\n\r\n    const sorter = params.sorter;\r\n    const direction = params.direction || \"descending\";\r\n    if (sorter) result.sort = `${sorter}:${direction}`;\r\n\r\n    return result;\r\n};\r\n\r\nconst _toSort = function(value) {\r\n    const values = value.split(\":\", 2);\r\n    if (values.length === 1) values.push(\"descending\");\r\n    const [name, direction] = values;\r\n    if (name === \"default\") return null;\r\n    values[1] = SORT_MAP[direction] || 1;\r\n    return [values];\r\n};\r\n\r\nconst _findTypes = function(params) {\r\n    const result = {};\r\n    Object.entries(params).forEach(([key, value]) => {\r\n        const converter = FIND_TYPES[key];\r\n        const converted = converter ? converter(value) : value;\r\n        result[key] = converted;\r\n    });\r\n    return result;\r\n};\r\n\r\nconst _findDefaults = function(params, options = {}) {\r\n    const result = Object.assign({}, params);\r\n    Object.entries(options)\r\n        .filter(([key]) => FIND_TYPES[key])\r\n        .forEach(([key, value]) => {\r\n            result[key] = params[key] || value;\r\n        });\r\n    Object.entries(FIND_DEFAULTS).forEach(([key, value]) => {\r\n        result[key] = params[key] || value;\r\n    });\r\n    return result;\r\n};\r\n\r\nconst _normParams = function(params) {\r\n    const result = Object.assign({}, params);\r\n\r\n    // iterates over all the key value association in the object,\r\n    // trying to find the ones that refer sequences so that they\r\n    // may be normalized\r\n    for (const [key, value] of Object.entries(params)) {\r\n        // verifies if the current name references a sequence and\r\n        // if that's not the case continues the loop trying to find\r\n        // any other sequence based value\r\n        if (!key.endsWith(\"[]\")) {\r\n            result[key] = value;\r\n            continue;\r\n        }\r\n\r\n        // removes the extra sequence indication value\r\n        const name = key.substring(0, key.length - 2);\r\n\r\n        // in case the current value is not valid (empty) the object\r\n        // is set with an empty list for the current iteration as this\r\n        // is considered to be the default value\r\n        if (!value) {\r\n            result[name] = [];\r\n            continue;\r\n        }\r\n\r\n        // retrieves the normalized and linearized list of leafs\r\n        // for the current value and ten verifies the size of each\r\n        // of its values and uses it to measure the number of\r\n        // dictionary elements that are going to be contained in\r\n        // the sequence to be \"generated\", then uses this (size)\r\n        // value to pre-generate the complete set of dictionaries\r\n        const leafs = _leafs(value);\r\n        const [, values] = leafs[0] || [null, []];\r\n        const list = values.map(_ => ({}));\r\n\r\n        // sets the list of generates dictionaries in the object for\r\n        // the newly normalized name of structure\r\n        result[name] = list;\r\n\r\n        // iterates over the complete set of key value pairs in the\r\n        // leafs list to gather the value into the various objects that\r\n        // are contained in the sequence (normalization process)\r\n        for (const [name, value] of leafs) {\r\n            for (let index; index < list.length; index++) {\r\n                const object = list[index];\r\n                const nameList = name.split(\".\");\r\n                _setObject(object, nameList, value[index]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Retrieves a list containing a series of tuples that each represent a\r\n * leaf of the current object structure. A leaf is the last element of an\r\n * object that is not a map, the other intermediary maps are considered to\r\n * be trunks and should be percolated recursively.\r\n * This is a recursive function that takes some memory for the construction\r\n * of the list, and so should be used with the proper care to avoid bottlenecks.\r\n *\r\n * @param {Object} params The object for which the leafs list structure is\r\n * meant to be retrieved.\r\n * @returns {Array} The list of leaf node tuples for the provided object,\r\n * as requested for each of the sequences.\r\n */\r\nconst _leafs = function(params) {\r\n    // the list that will hold the various leaf nodes \"gathered\" by\r\n    // the current recursion function\r\n    let result = [];\r\n\r\n    // iterates over all the key and value relations in the object trying\r\n    // to find the leaf nodes (no map nodes) creating a tuple of fqn\r\n    // (fully qualified name) and value\r\n    for (const [key, value] of Object.entries(params)) {\r\n        // retrieves the data type for the current value and validation\r\n        // if it is a object or any other type in case it's an object a\r\n        // new iteration step must be performed retrieving the leafs of\r\n        // the value and then incrementing the name with the current prefix\r\n        if (typeof value === \"object\") {\r\n            const leafs = _leafs(value).map(([name, value]) => [`${key}.${name}`, value]);\r\n            result = Array.concat(result, leafs);\r\n        } else {\r\n            // otherwise this is a leaf node and so the leaf tuple node\r\n            // must be constructed with the current value (properly validated\r\n            // for sequence presence)\r\n            result.push([key, Array.isArray(value) ? value : [value]]);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Sets a composite value in an object, allowing for dynamic setting of\r\n * random size key values.\r\n * This method is useful for situations where one wants to set a value\r\n * at a randomly defined depth inside an object without having to much\r\n * work with the creation of the inner dictionaries.\r\n *\r\n * @param {Object} object The target object that is going to be\r\n * changed and set with the target value.\r\n * @param {Array} nameList The list of names that defined the fully\r\n * qualified name to be used in the setting of the value\r\n * for example path.to.end will be a three size list containing each\r\n * of the partial names.\r\n * @param {Object} value The value that is going to be set in the\r\n * defined target of the object.\r\n */\r\nconst _setObject = function(object, nameList, value) {\r\n    // retrieves the first name in the names list this is the\r\n    // value that is going to be used for the current iteration\r\n    const [name, ...tail] = nameList[0];\r\n\r\n    // in case the length of the current names list has reached\r\n    // one this is the final iteration and so the value is set\r\n    // at the current naming point\r\n    if (nameList.length === 1) {\r\n        object[name] = value;\r\n    } else {\r\n        // otherwise this is a \"normal\" step and so a new map must\r\n        // be created/retrieved and the iteration step should be\r\n        // performed on this new map as it's set on the current naming\r\n        // place (recursion step)\r\n\r\n        const map = object[name] || {};\r\n        object[name] = map;\r\n        _setObject(map, tail, value);\r\n    }\r\n};\n\nclass MixinBuilder {\r\n    constructor(superclass) {\r\n        this.superclass = superclass;\r\n    }\r\n\r\n    with(...mixins) {\r\n        return mixins.reduce((c, mixin) => mixin(c), this.superclass);\r\n    }\r\n}\r\n\r\nconst mix = superclass => new MixinBuilder(superclass);\n\nconst initMongo = async (mongoose, uri) => {\r\n    mongoose.set(\"useNewUrlParser\", true);\r\n    mongoose.set(\"useFindAndModify\", false);\r\n    mongoose.set(\"useCreateIndex\", true);\r\n    mongoose.set(\"useUnifiedTopology\", true);\r\n    await mongoose.connect(uri, {\r\n        useNewUrlParser: true,\r\n        useUnifiedTopology: true\r\n    });\r\n};\r\n\r\nconst destroyMongo = mongoose => {\r\n    mongoose.disconnect();\r\n};\n\nconst equal = function(first, second) {\r\n    if (first === second) {\r\n        return true;\r\n    }\r\n\r\n    if (typeof_(first) !== typeof_(second)) {\r\n        return false;\r\n    }\r\n\r\n    if (isPrimitive(first) && isPrimitive(second)) {\r\n        return first === second;\r\n    }\r\n\r\n    if (first instanceof Date && second instanceof Date) {\r\n        return first === second;\r\n    }\r\n\r\n    if (Object.keys(first).length !== Object.keys(second).length) {\r\n        return false;\r\n    }\r\n\r\n    for (const key in first) {\r\n        if (!(key in second)) return false;\r\n        if (!equal(first[key], second[key])) return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst isPrimitive = function(object) {\r\n    return object !== Object(object);\r\n};\r\n\r\nconst typeof_ = function(object) {\r\n    if (object === null) return \"null\";\r\n    if (Array.isArray(object)) return \"array\";\r\n    return typeof object;\r\n};\n\nconst matchOperatorsRegex = /[|\\\\{}()[\\]^$+*?.-]/g;\r\n\r\nconst escapeStringRegexp = function(string) {\r\n    if (typeof string !== \"string\") {\r\n        throw new TypeError(\"Expected a string\");\r\n    }\r\n\r\n    return string.replace(matchOperatorsRegex, \"\\\\$&\");\r\n};\n\n/* The default minimum value meaning that this is the\r\nmaximum value that one integer value may have for the\r\nsize rounding operation to be performed */\r\nconst DEFAULT_MINIMUM = 1024;\r\n\r\n/* The default number of places (digits) that are going\r\nto be used for the string representation in the round\r\nbased conversion of size units to be performed */\r\nconst DEFAULT_PLACES = 3;\r\n\r\n/* The size unit coefficient as an integer value, this is\r\ngoing to be used in each of the size steps as divisor */\r\nconst SIZE_UNIT_COEFFICIENT = 1024;\r\n\r\n/* The simplified size units list that contains the complete set of\r\nunits indexed by the depth they represent */\r\nconst SIZE_UNITS_LIST_S = [\"B\", \"K\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\r\n\r\n/* The size units list that contains the complete set of\r\nunits indexed by the depth they represent */\r\nconst SIZE_UNITS_LIST = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\r\n\r\nconst sizeRoundUnit = function(\r\n    sizeValue,\r\n    minimum = DEFAULT_MINIMUM,\r\n    places = DEFAULT_PLACES,\r\n    reduce = true,\r\n    space = false,\r\n    justify = false,\r\n    simplified = false,\r\n    depth = 0\r\n) {\r\n    // in case the current size value is acceptable (less than\r\n    // the minimum) this is the final iteration and the final\r\n    // string representation is going to be created\r\n    if (sizeValue < minimum) {\r\n        // calculates the maximum size of the string that is going\r\n        // to represent the base size value as the number of places\r\n        // plus one (representing the decimal separator character)\r\n        const sizeS = places + 1;\r\n\r\n        // calculates the target number of decimal places taking\r\n        // into account the size (in digits) of the current size\r\n        // value, this may never be a negative number\r\n        const logValue = sizeValue && Math.log10(sizeValue);\r\n        const digits = Math.trunc(logValue) + 1;\r\n        places = places - digits;\r\n        places = places > 0 ? places : 0;\r\n\r\n        // rounds the size value, then converts the rounded\r\n        // size value into a string based representation\r\n        let sizeValueS = sizeValue.toFixed(places);\r\n\r\n        // forces the reduce flag when the depth is zero, meaning\r\n        // that an integer value will never be decimal, this is\r\n        // required to avoid strange results for depth zero\r\n        reduce = reduce || depth === 0;\r\n\r\n        // in case the dot value is not present in the size value\r\n        // string adds it to the end otherwise an issue may occur\r\n        // while removing extra padding characters for reduce\r\n        if (reduce && !sizeValueS.includes(\".\")) sizeValueS += \".\";\r\n\r\n        // strips the value from zero appended to the right and\r\n        // then strips the value also from a possible decimal\r\n        // point value that may be included in it, this is only\r\n        // performed in case the reduce flag is enabled\r\n        if (reduce) sizeValueS = sizeValueS.replace(/0+$/, \"\");\r\n        if (reduce) sizeValueS = sizeValueS.replace(/\\.$/, \"\");\r\n\r\n        // in case the justify flag is set runs the justification\r\n        // process on the size value taking into account the maximum\r\n        // size of the associated size string\r\n        if (justify) sizeValueS = _rjust(sizeValueS, sizeS);\r\n        // retrieves the size unit (string mode) for the current\r\n        // depth according to the provided map\r\n        let sizeUnit;\r\n        if (simplified) sizeUnit = SIZE_UNITS_LIST_S[depth];\r\n        else sizeUnit = SIZE_UNITS_LIST[depth];\r\n\r\n        // retrieves the appropriate separator based\r\n        // on the value of the space flag\r\n        const separator = (space && \" \") || \"\";\r\n\r\n        // creates the size value string appending the rounded\r\n        // size value string and the size unit and returns it\r\n        // to the caller method as the size value string\r\n        const sizeValueString = sizeValueS + separator + sizeUnit;\r\n        return sizeValueString;\r\n    }\r\n    // otherwise the value is not acceptable and a new iteration\r\n    // must be ran with one less depth of size value\r\n    else {\r\n        // re-calculates the new size value, increments the depth\r\n        // and runs the size round unit again with the new values\r\n        const newSizeValue = parseFloat(sizeValue) / SIZE_UNIT_COEFFICIENT;\r\n        const newDepth = depth + 1;\r\n        return sizeRoundUnit(\r\n            newSizeValue,\r\n            minimum,\r\n            places,\r\n            reduce,\r\n            space,\r\n            justify,\r\n            simplified,\r\n            newDepth\r\n        );\r\n    }\r\n};\r\n\r\nconst _rjust = function(str, length) {\r\n    const lengthToFill = length - str.length;\r\n    return lengthToFill <= 0 ? str : \" \".repeat(lengthToFill) + str;\r\n};\n\nconst camelToUnderscore = function(value, separator = \"_\") {\r\n    if (!value) return value;\r\n    return value\r\n        .replace(/\\.?([A-Z])/g, (x, y) => separator + y.toLowerCase())\r\n        .replace(RegExp(\"^\" + separator), \"\");\r\n};\r\n\r\nconst underscoreToCamel = function(value, lower = false, separator = \"_\") {\r\n    if (!value) return value;\r\n    const slices = value.split(separator);\r\n    return slices\r\n        .map((s, i) => {\r\n            if (i === 0 && lower) return s.charAt(0).toLowerCase() + s.slice(1);\r\n            return s.charAt(0).toUpperCase() + s.slice(1);\r\n        })\r\n        .join(\"\");\r\n};\n\n/**\r\n * Encodes the multiple values as and encoded URI component, the\r\n * values can be wither defined as an array (order is preserved)\r\n * or as an object (where sequence order is not preserved).\r\n *\r\n * The value of each item can be either a primitive type or a sequence\r\n * in case it's of sequence the values are going to be encoded as\r\n * multiple parameters separated by the '&' character.\r\n *\r\n * @param {(Array|Object[])} values The values to be encoded as an\r\n * URI component (like GET params).\r\n * @returns {String} A string with the query encoded values.\r\n */\r\nconst urlEncode = function(values) {\r\n    // constructs the parts array that is going to\r\n    // store the multiple and values\r\n    const parts = [];\r\n\r\n    // in case the provided value is not an array\r\n    // then assumes it's an object and retrieve entries\r\n    if (!Array.isArray(values)) {\r\n        values = Object.entries(values);\r\n    }\r\n\r\n    // iterates over the complete set of pairs available\r\n    // from the key value pairs to be able to encode them\r\n    // properly, notice that the values themselves can be\r\n    // sequences allowing multiple repetition of key\r\n    values.forEach(([key, value]) => {\r\n        if (!Array.isArray(value)) {\r\n            value = [value];\r\n        }\r\n        const keyEncoded = encodeURIComponent(key);\r\n        value.forEach(_value => {\r\n            if (_value === undefined || _value === null) {\r\n                return;\r\n            }\r\n            const valueEncoded = encodeURIComponent(_value);\r\n            parts.push(`${keyEncoded}=${valueEncoded}`);\r\n        });\r\n    });\r\n\r\n    // joins the complete set of parts with the and\r\n    // separator and then returns the final string value\r\n    return parts.join(\"&\");\r\n};\r\n\r\nconst absoluteUrl = function(path, name = \"BASE_URL\", fallback = undefined) {\r\n    const baseUrl = conf(name, fallback);\r\n    if (!baseUrl) return null;\r\n    return `${baseUrl}${path}`;\r\n};\n\nclass YoniusError extends Error {\r\n    constructor(message, code = 500) {\r\n        super(message);\r\n        this.name = this.constructor.name;\r\n        this.code = code;\r\n    }\r\n\r\n    get isClient() {\r\n        return Math.floor(this.code / 100) === 4;\r\n    }\r\n\r\n    get isServer() {\r\n        return Math.floor(this.code / 100) === 5;\r\n    }\r\n}\r\n\r\nclass OperationalError extends YoniusError {\r\n    constructor(message = \"Operational error\", code = 500) {\r\n        super(message, code);\r\n    }\r\n}\r\n\r\nclass NotFoundError extends OperationalError {\r\n    constructor(message = \"Not found\", code = 404) {\r\n        super(message, code);\r\n    }\r\n}\r\n\r\nclass NotImplementedError extends OperationalError {\r\n    constructor(message = \"Not implemented\", code = 501) {\r\n        super(message, code);\r\n    }\r\n}\r\n\r\nclass ValidationError extends OperationalError {\r\n    constructor(message = \"Validation of submitted data failed\", code = 400) {\r\n        super(message, code);\r\n    }\r\n}\r\n\r\nclass AttributeError extends YoniusError {\r\n    constructor(message = \"Attribute not found\") {\r\n        super(message);\r\n    }\r\n}\n\n/**\r\n * The simple regex used to validate\r\n * if the provided value is a \"simple\" one meaning\r\n * that it may be used safely for URL parts\r\n */\r\nconst SIMPLE_REGEX = /^[\\:\\.\\s\\w-]+$/;\r\n\r\n/**\r\n * The email regex used to validate\r\n * if the provided value is in fact an email\r\n */\r\nconst EMAIL_REGEX = /^[\\w\\d\\._%+-]+@[\\w\\d\\.\\-]+$/;\r\n\r\n/**\r\n * The URL regex used to validate\r\n * if the provided value is in fact an URL/URI\r\n */\r\nconst URL_REGEX = /^\\w+\\:\\/\\/([^@]+\\:[^@]+@)?[^\\:\\/\\?#]+(\\:\\d+)?(\\/[^\\?#]+)*\\/?(\\?[^#]*)?(#.*)?$/;\r\n\r\nconst eq = function(valueC, message = \"Must be equal to %{1}\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst gt = function(valueC, message = \"Must be greater than %{1}\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value > valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst gte = function(valueC, message = \"Must be greater than or equal to %{1}\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value >= valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst notEmpty = function(message = \"Value is empty\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value.length) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isIn = function(valueC, message = \"Value must be one of: %{1}\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (valueC.includes(value)) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", valueC.join(\", \")));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isUpper = function(message = \"Value contains lower cased characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value === value.toUpperCase()) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isLower = function(message = \"Value contains upper cased characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value === value.toLowerCase()) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isSimple = function(message = \"Value contains invalid characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value.match(SIMPLE_REGEX)) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isEmail = function(message = \"Value is not a valid email\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value.match(EMAIL_REGEX)) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isUrl = function(message = \"Value is not a valid URL\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value.match(URL_REGEX)) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst isRegex = function(regex, message = \"Value has incorrect format\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value === \"\") return true;\r\n        if (value.match(new RegExp(regex))) return true;\r\n        throw new ValidationError(message);\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst stringGt = function(valueC, message = \"Must be larger than %{1} characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value.length > valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst stringLt = function(valueC, message = \"Must be smaller than %{1} characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value.length < valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst stringEq = function(valueC, message = \"Must be exactly %{1} characters\") {\r\n    const validation = (value, ctx) => {\r\n        if (value === undefined) return true;\r\n        if (value === null) return true;\r\n        if (value.length === valueC) return true;\r\n        throw new ValidationError(message.replace(\"%{1}\", String(valueC)));\r\n    };\r\n    return validation;\r\n};\r\n\r\nconst all = function(validation) {\r\n    const _validation = (sequence, ctx) => {\r\n        if (sequence === undefined) return true;\r\n        if (sequence === null) return true;\r\n        for (const value of sequence) {\r\n            validation(value, ctx);\r\n        }\r\n        return true;\r\n    };\r\n    return _validation;\r\n};\n\nconst AUTH_ERRORS = [401, 403, 440, 499];\r\n\r\nclass API extends Observable {\r\n    constructor(kwargs = {}) {\r\n        super();\r\n        this.kwargs = kwargs;\r\n    }\r\n\r\n    async build(method, url, options = {}) {}\r\n\r\n    async authCallback(params, headers) {}\r\n\r\n    async get(url, options = {}) {\r\n        const result = await this.methodBasic(\"GET\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async post(url, options = {}) {\r\n        const result = await this.methodPayload(\"POST\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async put(url, options = {}) {\r\n        const result = await this.methodPayload(\"PUT\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async delete(url, options = {}) {\r\n        const result = await this.methodBasic(\"DELETE\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async patch(url, options = {}) {\r\n        const result = await this.methodPayload(\"PATCH\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async options(url, options = {}) {\r\n        const result = await this.methodBasic(\"OPTIONS\", url, options);\r\n        return result;\r\n    }\r\n\r\n    async methodBasic(method, url, options = {}) {\r\n        options.params = options.params !== undefined ? options.params : {};\r\n        options.headers = options.headers !== undefined ? options.headers : {};\r\n        try {\r\n            return await this._methodBasic(method, url, options);\r\n        } catch (err) {\r\n            if (AUTH_ERRORS.includes(err.code)) {\r\n                await this.authCallback(options.params, options.headers);\r\n                return await this._methodBasic(method, url, options);\r\n            } else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    async methodPayload(method, url, options = {}) {\r\n        options.params = options.params !== undefined ? options.params : {};\r\n        options.headers = options.headers !== undefined ? options.headers : {};\r\n        try {\r\n            return await this._methodPayload(method, url, options);\r\n        } catch (err) {\r\n            if (AUTH_ERRORS.includes(err.code)) {\r\n                await this.authCallback(options.params, options.headers);\r\n                return await this._methodPayload(method, url, options);\r\n            } else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    async _methodBasic(method, url, options = {}) {\r\n        const params = options.params !== undefined ? options.params : {};\r\n        const headers = options.headers !== undefined ? options.headers : {};\r\n        const kwargs = options.kwargs !== undefined ? options.kwargs : {};\r\n        const handle = options.handle !== undefined ? options.handle : true;\r\n        const getAgent = options.getAgent !== undefined ? options.getAgent : undefined;\r\n        await this.build(method, url, {\r\n            params: params,\r\n            headers: headers,\r\n            kwargs: kwargs\r\n        });\r\n        const query = urlEncode(params || {});\r\n        if (query) url += url.includes(\"?\") ? \"&\" + query : \"?\" + query;\r\n        const response = await fetch(url, {\r\n            method: method,\r\n            headers: headers || {},\r\n            agent: getAgent || globals.getAgent || undefined\r\n        });\r\n        const result = handle ? await this._handleResponse(response) : response;\r\n        return result;\r\n    }\r\n\r\n    async _methodPayload(method, url, options = {}) {\r\n        const params = options.params !== undefined ? options.params : {};\r\n        let headers = options.headers !== undefined ? options.headers : {};\r\n        let data = options.data !== undefined ? options.data : null;\r\n        const dataJ = options.dataJ !== undefined ? options.dataJ : null;\r\n        const dataM = options.dataM !== undefined ? options.dataM : null;\r\n        let mime = options.mime !== undefined ? options.mime : null;\r\n        const kwargs = options.kwargs !== undefined ? options.kwargs : {};\r\n        const handle = options.handle !== undefined ? options.handle : true;\r\n        const getAgent = options.getAgent !== undefined ? options.getAgent : undefined;\r\n\r\n        await this.build(method, url, {\r\n            params: params,\r\n            headers: headers,\r\n            data: data,\r\n            dataJ: dataJ,\r\n            dataM: dataM,\r\n            mime: mime,\r\n            kwargs: kwargs\r\n        });\r\n\r\n        const query = urlEncode(params || {});\r\n\r\n        if (data !== null) {\r\n            if (query) url += url.includes(\"?\") ? \"&\" + query : \"?\" + query;\r\n        } else if (dataJ !== null) {\r\n            data = JSON.stringify(dataJ);\r\n            if (query) url += url.includes(\"?\") ? \"&\" + query : \"?\" + query;\r\n            mime = mime || \"application/json\";\r\n        } else if (dataM !== null) {\r\n            if (query) url += url.includes(\"?\") ? \"&\" + query : \"?\" + query;\r\n            [mime, data] = this._encodeMultipart(dataM, mime, true);\r\n        } else if (query) {\r\n            data = query;\r\n            mime = mime || \"application/x-www-form-urlencoded\";\r\n        }\r\n\r\n        headers = Object.assign({}, headers);\r\n        if (mime) headers[\"Content-Type\"] = mime;\r\n\r\n        const response = await fetch(url, {\r\n            method: method,\r\n            headers: headers || {},\r\n            body: data,\r\n            agent: getAgent || global.getAgent || undefined\r\n        });\r\n        const result = handle ? await this._handleResponse(response) : response;\r\n        return result;\r\n    }\r\n\r\n    async _handleResponse(response, errorMessage = \"Problem in request\") {\r\n        let result = null;\r\n        if (\r\n            response.headers.get(\"content-type\") &&\r\n            response.headers.get(\"content-type\").toLowerCase().startsWith(\"application/json\")\r\n        ) {\r\n            result = await response.json();\r\n        } else if (\r\n            response.headers.get(\"content-type\") &&\r\n            response.headers.get(\"content-type\").toLowerCase().startsWith(\"text/\")\r\n        ) {\r\n            result = await response.text();\r\n        } else {\r\n            result = await response.blob();\r\n        }\r\n        verify(response.ok, result.error || errorMessage, response.status || 500);\r\n        return result;\r\n    }\r\n\r\n    _encodeMultipart(fields, mime = null, doseq = false) {\r\n        mime = mime || \"multipart/form-data\";\r\n\r\n        const boundary = this._createBoundary(fields, undefined, doseq);\r\n\r\n        const encoder = new TextEncoder(\"utf-8\");\r\n\r\n        const buffer = [];\r\n\r\n        for (let [key, values] of Object.entries(fields)) {\r\n            const isList = doseq && Array.isArray(values);\r\n            values = isList ? values : [values];\r\n\r\n            for (let value of values) {\r\n                if (value === null) continue;\r\n\r\n                let header;\r\n\r\n                if (\r\n                    typeof value === \"object\" &&\r\n                    !(value instanceof Array) &&\r\n                    value.constructor !== Uint8Array\r\n                ) {\r\n                    const headerL = [];\r\n                    let data = null;\r\n                    for (const [key, item] of Object.entries(value)) {\r\n                        if (key === \"data\") data = item;\r\n                        else headerL.push(`${key}: ${item}`);\r\n                    }\r\n                    value = data;\r\n                    header = headerL.join(\"\\r\\n\");\r\n                } else if (value instanceof Array) {\r\n                    let name = null;\r\n                    let contents = null;\r\n                    let contentTypeD = null;\r\n                    if (value.length === 2) [name, contents] = value;\r\n                    else [name, contentTypeD, contents] = value;\r\n                    header = `Content-Disposition: form-data; name=\"${key}\"; filename=\"${name}\"`;\r\n                    if (contentTypeD) header += `\\r\\nContent-Type: ${contentTypeD}`;\r\n                    value = contents;\r\n                } else {\r\n                    header = `Content-Disposition: form-data; name=\"${key}\"`;\r\n                    value = value.constructor === Uint8Array ? value : encoder.encode(value);\r\n                }\r\n\r\n                buffer.push(encoder.encode(\"--\" + boundary + \"\\r\\n\"));\r\n                buffer.push(encoder.encode(header + \"\\r\\n\"));\r\n                buffer.push(encoder.encode(\"\\r\\n\"));\r\n                buffer.push(value);\r\n                buffer.push(encoder.encode(\"\\r\\n\"));\r\n            }\r\n        }\r\n\r\n        buffer.push(encoder.encode(\"--\" + boundary + \"--\\r\\n\"));\r\n        buffer.push(encoder.encode(\"\\r\\n\"));\r\n        const body = this._joinBuffer(buffer);\r\n        const contentType = `${mime}; boundary=${boundary}`;\r\n\r\n        return [contentType, body];\r\n    }\r\n\r\n    _createBoundary(fields, size = 32, doseq = false) {\r\n        return \"Vq2xNWWHbmWYF644q9bC5T2ALtj5CynryArNQRXGYsfm37vwFKMNsqPBrpPeprFs\";\r\n    }\r\n\r\n    _joinBuffer(bufferArray) {\r\n        const bufferSize = bufferArray.map(item => item.byteLength).reduce((a, v) => a + v, 0);\r\n        const buffer = new Uint8Array(bufferSize);\r\n        let offset = 0;\r\n        for (const item of bufferArray) {\r\n            buffer.set(item, offset);\r\n            offset += item.byteLength;\r\n        }\r\n        return buffer;\r\n    }\r\n}\r\n\r\nconst buildGetAgent = (AgentHttp, AgentHttps, set = true, options = {}) => {\r\n    const httpAgent = new AgentHttp({\r\n        keepAlive: options.keepAlive === undefined ? true : options.keepAlive,\r\n        keepAliveMsecs: options.keepAliveMsecs || 120000,\r\n        timeout: options.timeout || 60000,\r\n        scheduling: options.scheduling || \"fifo\"\r\n    });\r\n    const httpsAgent = new AgentHttps({\r\n        keepAlive: options.keepAlive === undefined ? true : options.keepAlive,\r\n        keepAliveMsecs: options.keepAliveMsecs || 120000,\r\n        timeout: options.timeout || 60000,\r\n        scheduling: options.scheduling || \"fifo\"\r\n    });\r\n    const getAgent = parsedURL => (parsedURL.protocol === \"http:\" ? httpAgent : httpsAgent);\r\n    if (set) globals.getAgent = getAgent;\r\n    return getAgent;\r\n};\r\n\r\n/**\r\n * Tries to patch the global environment with a proper `getAgent`\r\n * function that can handle HTTP and HTTP connection polling.\r\n *\r\n * This can only be performed in a node.js environment (uses `require`).\r\n *\r\n * @returns {Function} The `getAgent` function that has just been\r\n * built and set in the globals.\r\n */\r\nconst patchAgent = () => {\r\n    if (typeof require !== \"function\") return;\r\n    if (globals.getAgent) return;\r\n    let http, https;\r\n    try {\r\n        http = require(\"http\");\r\n        https = require(\"https\");\r\n    } catch (err) {\r\n        return;\r\n    }\r\n    if (!http || !https) return;\r\n    if (!http.Agent || !https.Agent) return;\r\n    return buildGetAgent(http.Agent, https.Agent, true);\r\n};\r\n\r\n// patches the global agent if possible, using the\r\n// global dynamic require statements\r\npatchAgent();\n\nclass OAuthAPI extends API {}\n\nclass OAuth1API extends OAuthAPI {}\n\nclass OAuth2API extends OAuthAPI {\r\n    constructor(kwargs = {}) {\r\n        super(kwargs);\r\n        this.accessToken = null;\r\n    }\r\n\r\n    async build(method, url, options = {}) {\r\n        await super.build(method, url, options);\r\n        const params = options.params !== undefined ? options.params : {};\r\n        const headers = options.headers !== undefined ? options.headers : {};\r\n        const kwargs = options.kwargs !== undefined ? options.kwargs : {};\r\n        const token = kwargs.token === undefined ? this.tokenDefault : kwargs.token;\r\n        delete kwargs.token;\r\n        if (token && this.oauthTypes.includes(\"param\")) {\r\n            params[this.oauthParam] = this.getAccessToken();\r\n        }\r\n        if (token && this.oauthTypes.includes(\"header\")) {\r\n            headers.Authorization = `Bearer ${this.getAccessToken()}`;\r\n        }\r\n    }\r\n\r\n    getAccessToken() {\r\n        if (this.accessToken) return this.accessToken;\r\n        throw new Error(\"No access token found must re-authorize\");\r\n    }\r\n\r\n    get oauthTypes() {\r\n        return [\"param\", \"header\"];\r\n    }\r\n\r\n    get oauthParam() {\r\n        return \"access_token\";\r\n    }\r\n\r\n    get tokenDefault() {\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * Ensures that the current \"session\" context contains the\r\n * requested ACL token as valid.\r\n *\r\n * In case the validation fails an exception is raised\r\n * indicating the auth validation error.\r\n *\r\n * @param {String} token The ACL token to ensure permission,\r\n * the logged user should be allowed to id.\r\n * @param {Object} ctx The context object to be used in\r\n * the session basic ACL retrieval, should contain proper\r\n * injected methods for retrieval (eg: `getAcl`).\r\n */\r\nconst ensurePermissions = async (token, ctx) => {\r\n    // retrieves the ACL values from the current context and\r\n    // then uses the ACL to obtain the valid expanded tokens map\r\n    const acl = ctx.getAcl ? await ctx.getAcl(ctx) : {};\r\n    const tokens = toTokensM(acl);\r\n\r\n    // in case the permission validation test is not positive\r\n    // then an exception should be raised indicating the issue\r\n    if (!hasPermission(token, tokens)) {\r\n        throw new OperationalError(\"You don't have authorization to access this resource\", 401);\r\n    }\r\n};\r\n\r\n/**\r\n * Converts the provided list of token strings separated by dots\r\n * into a map based representation on an hierarchical structure.\r\n *\r\n * @param {Array} tokens A linear array of tokens to convert into\r\n * an hierarchical representation.\r\n * @returns {Object} The map containing the hierarchy of tokens\r\n * for the provided linear string based sequence of tokens.\r\n */\r\nconst toTokensM = tokens => {\r\n    const tokensM = {};\r\n\r\n    if (tokens === undefined) return tokensM;\r\n    if (tokens === null) return tokensM;\r\n    if (!Array.isArray(tokens)) return tokensM;\r\n\r\n    for (const token of tokens) {\r\n        let tokensC = tokensM;\r\n        const tokenL = token.split(\".\");\r\n        const head = tokenL.slice(0, tokenL.length - 1);\r\n        const tail = tokenL[tokenL.length - 1];\r\n\r\n        for (const tokenP of head) {\r\n            let current = tokensC[tokenP] || {};\r\n            const isDict = typeof current === \"object\";\r\n            if (!isDict) current = { _: current };\r\n            tokensC[tokenP] = current;\r\n            tokensC = current;\r\n        }\r\n\r\n        const leaf = tokensC[tail] || null;\r\n        if (leaf && typeof leaf === \"object\") leaf._ = true;\r\n        else tokensC[tail] = true;\r\n    }\r\n\r\n    return tokensM;\r\n};\r\n\r\nconst hasPermission = (token, tokensM = null) => {\r\n    if (!token) return true;\r\n    if (tokensM === undefined || tokensM === null) return false;\r\n\r\n    const tokenL = token.split(\".\");\r\n    for (const tokenP of tokenL) {\r\n        if (typeof tokensM !== \"object\") return false;\r\n        if (tokensM[\"*\"]) return true;\r\n        if (tokensM[tokenP] === undefined) return false;\r\n        tokensM = tokensM[tokenP];\r\n    }\r\n\r\n    const isDict = typeof tokensM === \"object\";\r\n    const result = isDict ? tokensM._ || false : tokensM;\r\n\r\n    return Boolean(result);\r\n};\n\nconst REGISTRY = {};\r\n\r\nconst load = async function() {\r\n    await load$1();\r\n};\r\n\r\nconst unload = async function() {};\r\n\r\nconst register = function(name, value) {\r\n    REGISTRY[name] = value;\r\n};\r\n\r\nconst unregister = function(name) {\r\n    delete REGISTRY[name];\r\n};\r\n\r\nconst request = function(name) {\r\n    if (REGISTRY[name] === undefined) {\r\n        throw new OperationalError(`Name '${name}' not found in registry`);\r\n    }\r\n    return REGISTRY[name];\r\n};\n\nclass FileTuple extends Array {\r\n    static fromData(data, name = null, mime = null) {\r\n        const fileTuple = new this(name, mime, data);\r\n        return fileTuple;\r\n    }\r\n\r\n    static fromString(dataString, name = null, mime = null, { encoding = \"utf-8\" } = {}) {\r\n        const data = new TextEncoder(encoding).encode(dataString);\r\n        return this.fromData(data, name, mime);\r\n    }\r\n\r\n    static fromArrayBuffer(arrayBuffer, name = null, mime = null) {\r\n        const buffer = Buffer.from(arrayBuffer);\r\n        return this.fromData(buffer, name, mime);\r\n    }\r\n\r\n    static async fromBlob(blob, name = null, mime = null) {\r\n        const arrayBuffer = await blob.arrayBuffer();\r\n        return this.fromArrayBuffer(arrayBuffer, name, mime);\r\n    }\r\n\r\n    get name() {\r\n        return this[0];\r\n    }\r\n\r\n    get mime() {\r\n        return this[1];\r\n    }\r\n\r\n    get data() {\r\n        return this[2];\r\n    }\r\n}\n\nclass AbstractType {\r\n    async jsonV() {\r\n        return JSON.stringify(this);\r\n    }\r\n\r\n    async mapV() {\r\n        const result = await this.jsonV();\r\n        return result;\r\n    }\r\n}\r\n\r\nclass Reference extends AbstractType {}\r\n\r\nconst reference = function(target, { name = null, dumpall = false } = {}) {\r\n    name = name || \"id\";\r\n    const targetT = target.constructor.name;\r\n    const isReference = targetT === \"string\";\r\n    const reserved = [\"id\", \"_target\", \"_object\", \"_type\", \"__dict__\"];\r\n\r\n    class _Reference extends Reference {\r\n        constructor(id) {\r\n            super(id);\r\n\r\n            this.__start__();\r\n\r\n            const proxy = new Proxy(this, {\r\n                get(target, name) {\r\n                    // special case to avoid this Proxy\r\n                    // breaking when being accessed in\r\n                    // an async context\r\n                    if (name === \"then\") return target.then;\r\n\r\n                    if (name in target) return target[name];\r\n\r\n                    const exists = Boolean(target._object && target._object[name]);\r\n                    if (exists) return target._object[name];\r\n                    if (target.isResolved) throw new AttributeError(`'${name}' not found`);\r\n                    return target.get(name);\r\n                },\r\n                set(target, name, value) {\r\n                    if (name in target) {\r\n                        target[name] = value;\r\n                        return true;\r\n                    }\r\n\r\n                    // verifies if the reference object exists in the current\r\n                    // reference instance, that's the case if the object name is\r\n                    // defined in the dictionary and the referenced object contains\r\n                    // an attribute with the name referred, for those situations\r\n                    // defers the setting of the attribute to the reference object\r\n                    const exists =\r\n                        target._object !== undefined && target._object[name] !== undefined;\r\n                    if (exists) {\r\n                        target._object[name] = value;\r\n                        return true;\r\n                    }\r\n\r\n                    // otherwise this is a normal attribute setting and the current\r\n                    // object's dictionary must be changed so that the new value is set\r\n                    target[name] = value;\r\n                    return true;\r\n                }\r\n            });\r\n\r\n            if (id instanceof _Reference) return this.buildI(id);\r\n            else if (id instanceof this.constructor._target) return this.buildO(id);\r\n            else this.build(id);\r\n\r\n            return proxy;\r\n        }\r\n\r\n        static get schema() {\r\n            return target.schema;\r\n        }\r\n\r\n        static get schemaSafe() {\r\n            return target.schemaSafe;\r\n        }\r\n\r\n        static get collection() {\r\n            return target.collection;\r\n        }\r\n\r\n        static get idName() {\r\n            return \"id\";\r\n        }\r\n\r\n        static get increments() {\r\n            return target.increments;\r\n        }\r\n\r\n        static get dataOptions() {\r\n            return target.dataOptions;\r\n        }\r\n\r\n        static _collection(options) {\r\n            return target._collection(options);\r\n        }\r\n\r\n        static async _increment(name) {\r\n            return target._increment(name);\r\n        }\r\n\r\n        static async _ensureMin(name, value) {\r\n            return target._ensureMin(name, value);\r\n        }\r\n\r\n        static _eagerB(eager) {\r\n            return target._eagerB(eager);\r\n        }\r\n\r\n        async get(name) {\r\n            await this.resolve();\r\n            const value = this._object[name];\r\n            if (value === undefined) throw new AttributeError(`'${name}' not found`);\r\n            return value;\r\n        }\r\n\r\n        async set(name, value) {\r\n            // in case the name that is being set is not part of the reserved\r\n            // names for the reference underlying structure the object resolution\r\n            // is triggered to make sure the underlying object exists and is loaded\r\n            if (!reserved.includes(name)) {\r\n                await target.resolve();\r\n            }\r\n\r\n            // verifies if the reference object exists in the current\r\n            // reference instance, that's the case if the object name is\r\n            // defined in the dictionary and the referenced object contains\r\n            // an attribute with the name referred, for those situations\r\n            // defers the setting of the attribute to the reference object\r\n            const exists = this._object !== undefined && this._object[name] !== undefined;\r\n            if (exists) {\r\n                this._object[name] = value;\r\n                return true;\r\n            }\r\n\r\n            // otherwise this is a normal attribute setting and the current\r\n            // object's dictionary must be changed so that the new value is set\r\n            this[name] = value;\r\n        }\r\n\r\n        __start__() {\r\n            if (isReference) this._target = this.constructor._target;\r\n            else this._target = target;\r\n            verify(this._target);\r\n            const meta = this._target.schema[name];\r\n            this._type = meta.type || String;\r\n        }\r\n\r\n        /**\r\n         * The name of the key (join) attribute for the\r\n         * reference that is going to be created, this\r\n         * name may latter be used to cast the value\r\n         */\r\n        static get _name() {\r\n            return name;\r\n        }\r\n\r\n        static get _default() {\r\n            return new this(null);\r\n        }\r\n\r\n        static get _target() {\r\n            if (isReference) {\r\n                throw new NotImplementedError(\"References only work with classes, not class names\");\r\n            }\r\n            return target;\r\n        }\r\n\r\n        static _btype() {\r\n            let _target;\r\n            if (isReference) _target = this._target();\r\n            else _target = target;\r\n            const meta = _target.schema[name];\r\n            return meta.type || String;\r\n        }\r\n\r\n        build(id, cast = true) {\r\n            const isUnset = [\"\", null, undefined].includes(id);\r\n            cast = cast && !isUnset;\r\n            if (cast) id = this.constructor._target.cast(name, id);\r\n            this.id = id;\r\n            this._object = null;\r\n        }\r\n\r\n        buildI(reference) {\r\n            this.id = reference.id;\r\n            this._object = reference._object;\r\n        }\r\n\r\n        buildO(object) {\r\n            this.id = object[this.constructor._name];\r\n            this._object = object;\r\n        }\r\n\r\n        async refV() {\r\n            return this.val;\r\n        }\r\n\r\n        async jsonV() {\r\n            if (dumpall) {\r\n                const result = await this.resolve();\r\n                return result;\r\n            }\r\n            return this.val;\r\n        }\r\n\r\n        async mapV() {\r\n            throw new NotImplementedError();\r\n        }\r\n\r\n        get val() {\r\n            const isEmpty = [\"\", null, undefined].includes(this.id);\r\n            if (isEmpty) return null;\r\n            return this._type(this.id);\r\n        }\r\n\r\n        async resolve(kwargs = {}) {\r\n            // verifies if the underlying object reference exists\r\n            // in the current names dictionary and if it exists\r\n            // verifies if it's valid (value is valid) if that's\r\n            // the case returns the current value immediately\r\n            const exists = this._object !== undefined;\r\n            if (exists && this._object) return this._object;\r\n\r\n            // verifies if there's an id value currently set in\r\n            // the reference in case it does not exists sets the\r\n            // object value in the current instance with a none\r\n            // value and then returns this (invalid value)\r\n            if (!this.id) {\r\n                const _object = null;\r\n                this._object = _object;\r\n                return _object;\r\n            }\r\n\r\n            // creates the map of keyword based arguments that are going\r\n            // to be used in the resolution of the reference and uses the\r\n            // data source based get attribute to retrieve the object\r\n            // that represents the reference\r\n            kwargs[name] = this.constructor._target.cast(name, this.id);\r\n            kwargs.raiseE = kwargs.raiseE || false;\r\n            kwargs.eagerL = kwargs.eagerL || false;\r\n            kwargs.resolveA = kwargs.resolveA || false;\r\n            const _object = await this.constructor._target.get(kwargs);\r\n\r\n            // sets the resolved object (using the current id attribute)\r\n            // in the current instance's dictionary and then returns this\r\n            // value to the caller method as the resolved value\r\n            this._object = _object;\r\n            return _object;\r\n        }\r\n\r\n        get isResolved() {\r\n            const exists = this._object !== undefined;\r\n            return Boolean(exists && this._object);\r\n        }\r\n\r\n        async isResolvable() {\r\n            await this.resolve();\r\n            return this._object !== null;\r\n        }\r\n    }\r\n\r\n    return _Reference;\r\n};\r\n\r\nclass References extends AbstractType {}\r\n\r\nconst references = function(target, { name = undefined, dumpall = false } = {}) {\r\n    name = name || \"id\";\r\n    const targetT = target.constructor.name;\r\n    const isReference = targetT === \"string\";\r\n    const ReferenceC = reference(target, { name: name, dumpall: dumpall });\r\n\r\n    class _References extends References {\r\n        constructor(ids) {\r\n            super(ids);\r\n\r\n            this.__start__();\r\n\r\n            const proxy = new Proxy(this, {\r\n                get(target, name) {\r\n                    if (name in target) return target[name];\r\n                    return target.objects[name];\r\n                }\r\n            });\r\n\r\n            if (ids instanceof _References) return this.buildI(ids);\r\n            else this.build(ids);\r\n\r\n            return proxy;\r\n        }\r\n\r\n        __start__() {\r\n            if (isReference) this._target = this.constructor._target;\r\n            else this._target = target;\r\n            verify(this._target);\r\n        }\r\n\r\n        /**\r\n         * The name of the key (join) attribute for the\r\n         * reference that is going to be created, this\r\n         * name may latter be used to cast the value\r\n         */\r\n        static get _name() {\r\n            return name;\r\n        }\r\n\r\n        static get _default() {\r\n            return new this([]);\r\n        }\r\n\r\n        static get _target() {\r\n            return ReferenceC._target;\r\n        }\r\n\r\n        static _btype() {\r\n            return ReferenceC._btype;\r\n        }\r\n\r\n        get items() {\r\n            return this.objects;\r\n        }\r\n\r\n        build(ids) {\r\n            const isValid = ![null, undefined].includes(ids);\r\n            if (isValid && !Array.isArray(ids)) ids = [ids];\r\n\r\n            this.ids = ids;\r\n            this.objects = [];\r\n            this.objectsM = {};\r\n\r\n            this.setIds(this.ids);\r\n        }\r\n\r\n        buildI(references) {\r\n            this.ids = references.ids;\r\n            this.objects = references.objects;\r\n            this.objectsM = references.objectsM;\r\n        }\r\n\r\n        setIds(ids = []) {\r\n            this.ids = [];\r\n            ids.forEach(id => {\r\n                if ([\"\", null, undefined].includes(id)) return;\r\n                const object = new ReferenceC(id);\r\n                const objectId = object.id;\r\n                this.ids.push(objectId);\r\n                this.objects.push(object);\r\n                this.objectsM[objectId] = object;\r\n            });\r\n        }\r\n\r\n        async refV() {\r\n            const result = await Promise.all(this.objects.map(async object => await object.refV()));\r\n            return result;\r\n        }\r\n\r\n        async jsonV() {\r\n            const result = await Promise.all(\r\n                this.objects.map(async object => await object.jsonV())\r\n            );\r\n            return result;\r\n        }\r\n\r\n        async mapV() {\r\n            const result = await Promise.all(this.objects.map(async object => await object.mapV()));\r\n            return result;\r\n        }\r\n\r\n        get val() {\r\n            return this.objects.map(object => object.val);\r\n        }\r\n\r\n        get list() {\r\n            return this.objects.map(object => object.val);\r\n        }\r\n\r\n        async resolve(kwargs = {}) {\r\n            const result = await Promise.all(this.objects.map(object => object.resolve(kwargs)));\r\n            return result;\r\n        }\r\n\r\n        find(kwargs = {}) {\r\n            kwargs[name] = {\r\n                $in: this.ids.map(id => this._target.cast(name, id))\r\n            };\r\n            return this._target.find(kwargs);\r\n        }\r\n\r\n        paginate(kwargs = {}) {\r\n            kwargs[name] = {\r\n                $in: this.ids.map(id => this._target.cast(name, id))\r\n            };\r\n            return this._target.paginate(kwargs);\r\n        }\r\n\r\n        get isEmpty() {\r\n            const idsL = self.ids.length;\r\n            return idsL === 0;\r\n        }\r\n\r\n        get isResolved() {\r\n            if (this.objects.length === 0) return true;\r\n            return this.objects[0].isResolved;\r\n        }\r\n    }\r\n\r\n    return _References;\r\n};\n\n/**\r\n * A mapping from yonius types to the schema types to\r\n * be used by the underlying Mongo collection.\r\n */\r\nconst MONGO_TYPES = [\r\n    [Reference, Object],\r\n    [References, Array]\r\n];\r\n\r\n/**\r\n * Abstract class definition that defines the interface\r\n * expected to be implemented by data driven collections\r\n * in the Yonius context.\r\n */\r\nclass Collection {\r\n    constructor(options) {\r\n        this.options = options;\r\n    }\r\n\r\n    async find(conditions, projection = {}, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async findOne(conditions, projection = {}, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async findOneAndUpdate(conditions, data, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async findOneAndDelete(conditions, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async create(data, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    async count(conditions, options = {}) {\r\n        throw new NotImplementedError();\r\n    }\r\n}\r\n\r\n/**\r\n * Mongo based collection that implements the collection\r\n * abstract interface applying it to a specific mongodb\r\n * instance. Most of the interface is already \"mongodb\r\n * oriented\", so only a thin layer of adaptation is required.\r\n */\r\nclass MongoCollection extends Collection {\r\n    constructor(name, schema) {\r\n        super(name, schema);\r\n        this._mongoose = this.constructor.getModel(this.options.name, this.options.schema);\r\n    }\r\n\r\n    static getModel(name, schema) {\r\n        // verifies if the model is already present in the global\r\n        // cache and if that the case re-uses it\r\n        this._models = this._models || {};\r\n        if (this._models[name]) return this._models[name];\r\n\r\n        // obtains a reference to the mongoose, that\r\n        // should have been registered by 3rd party\r\n        const mongoose = request(\"mongoose\");\r\n\r\n        // creates the internal \"mongoose\" reference to the\r\n        // model by encapsulating its name and schema\r\n        const filteredSchema = { ...schema };\r\n        Object.entries(filteredSchema).forEach(([name, value]) => {\r\n            const found = MONGO_TYPES.find(\r\n                ([type, mongoType]) => value.type.prototype instanceof type\r\n            );\r\n            if (!found) return;\r\n            filteredSchema[name].type = found[1];\r\n        });\r\n        this._models[name] = mongoose.model(name, new mongoose.Schema(filteredSchema));\r\n\r\n        // returns the newly constructor mongoose model to\r\n        // the caller methods\r\n        return this._models[name];\r\n    }\r\n\r\n    async find(conditions, projection = {}, options = {}) {\r\n        const model = await this._mongoose.find(conditions, projection, options);\r\n        return model;\r\n    }\r\n\r\n    async findOne(conditions, projection = {}, options = {}) {\r\n        const model = this._mongoose.findOne(conditions, projection, options);\r\n        return model;\r\n    }\r\n\r\n    async findOneAndUpdate(conditions, data, options = {}) {\r\n        const model = await this._mongoose.findOneAndUpdate(conditions, data, {\r\n            upsert: true,\r\n            new: true,\r\n            ...options\r\n        });\r\n        return model;\r\n    }\r\n\r\n    async findOneAndDelete(conditions, options = {}) {\r\n        const model = await this._mongoose.findOneAndDelete(conditions, options);\r\n        return model;\r\n    }\r\n\r\n    async create(data, options = {}) {\r\n        const models = await this._mongoose.create([data], options);\r\n        return models[0];\r\n    }\r\n\r\n    async count(conditions, options = {}) {\r\n        const count = await this._mongoose.countDocuments(conditions);\r\n        return count;\r\n    }\r\n}\n\nvar collection = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Collection: Collection,\n    MongoCollection: MongoCollection,\n    'default': Collection\n});\n\nconst MEMORY_STORAGE = {};\r\n\r\n/**\r\n * Simple lambda function that removes any\r\n * empty element from the provided list values\r\n */\r\nconst RE = v => v.filter(i => i !== \"\");\r\n\r\n/**\r\n * The map associating the various types with the\r\n * custom builder functions to be used when applying\r\n * the types function, this is relevant for the built-in\r\n * types that are meant to avoid using the default constructor\r\n */\r\nconst BUILDERS = {\r\n    [Number]: v => v,\r\n    [String]: v => v,\r\n    [Array]: v => (Array.isArray(v) ? RE(v) : typeof v === \"string\" ? JSON.parse(v) : RE([v])),\r\n    [Boolean]: v => (typeof v === \"boolean\" ? v : ![\"\", \"0\", \"false\", \"False\"].includes(v)),\r\n    [Object]: v => (typeof v === \"string\" ? JSON.parse(v) : v)\r\n};\r\n\r\n/**\r\n * The default values to be set when a type\r\n * conversion fails for the provided string value\r\n * the resulting value may be returned when a validation\r\n * fails an so it must be used carefully\r\n */\r\nconst TYPE_DEFAULTS = {\r\n    bytes: null,\r\n    unicode: null,\r\n    int: null,\r\n    float: null,\r\n    bool: false,\r\n    list: () => [],\r\n    dict: () => ({}),\r\n    object: () => ({})\r\n};\r\n\r\n/**\r\n * The various data types that are considered to be references\r\n * so that they are lazy loaded from the data source, these kind\r\n * of types should be compliant to a common interface so that they\r\n * may be used \"blindly\" from an external entity\r\n */\r\nconst TYPE_REFERENCES = [Reference, References];\r\n\r\n/**\r\n * The map that associates the various operators with the boolean\r\n * values that define if an insensitive base search should be used\r\n * instead of the \"typical\" sensitive search.\r\n */\r\nconst INSENSITIVE = {\r\n    likei: true,\r\n    llikei: true,\r\n    rlikei: true\r\n};\r\n\r\n/**\r\n * The map containing the mapping association between the\r\n * normalized version of the operators and the infra-structure\r\n * specific value for each of this operations, note that some\r\n * of the values don't have a valid mapping for this operations\r\n * the operator must be ignored and not used explicitly.\r\n */\r\nconst OPERATORS = {\r\n    eq: null,\r\n    equals: null,\r\n    ne: \"$ne\",\r\n    not_equals: \"$ne\",\r\n    in: \"$in\",\r\n    nin: \"$nin\",\r\n    not_in: \"$nin\",\r\n    like: \"$regex\",\r\n    likei: \"$regex\",\r\n    llike: \"$regex\",\r\n    llikei: \"$regex\",\r\n    rlike: \"$regex\",\r\n    rlikei: \"$regex\",\r\n    gt: \"$gt\",\r\n    greater: \"$gt\",\r\n    gte: \"$gte\",\r\n    greater_equal: \"$gte\",\r\n    lt: \"$lt\",\r\n    lesser: \"$lt\",\r\n    lte: \"$lte\",\r\n    lesser_equal: \"$lte\",\r\n    null: null,\r\n    is_null: null,\r\n    not_null: \"$ne\",\r\n    is_not_null: \"$ne\",\r\n    contains: \"$all\"\r\n};\r\n\r\n/**\r\n * Map that associates each of the normalized operations with\r\n * an inline function that together with the data type maps the\r\n * the base string based value into the target normalized value.\r\n */\r\nconst VALUE_METHODS = {\r\n    in: (v, t) => v.split(\";\").map(t),\r\n    not_in: (v, t) => v.split(\";\").map(t),\r\n    like: (v, t) => \"^.*\" + escapeStringRegexp(v) + \".*$\",\r\n    likei: (v, t) => \"^.*\" + escapeStringRegexp(v) + \".*$\",\r\n    llike: (v, t) => \"^.*\" + escapeStringRegexp(v) + \"$\",\r\n    llikei: (v, t) => \"^.*\" + escapeStringRegexp(v) + \"$\",\r\n    rlike: (v, t) => \"^\" + escapeStringRegexp(v) + \".*$\",\r\n    rlikei: (v, t) => \"^\" + escapeStringRegexp(v) + \".*$\",\r\n    null: (v, t) => null,\r\n    is_null: (v, t) => null,\r\n    not_null: (v, t) => null,\r\n    is_not_null: (v, t) => null,\r\n    contains: (v, t) => v.split(\";\").map(t)\r\n};\r\n\r\nclass Model {\r\n    constructor(options = {}) {\r\n        const fill = options.fill === undefined ? true : options.fill;\r\n        if (fill) this.constructor.fill(this);\r\n    }\r\n\r\n    static niw() {\r\n        return new this();\r\n    }\r\n\r\n    /**\r\n     * Fills the current model with the proper values so that\r\n     * no values are unset as this would violate the model definition\r\n     * integrity. This is required when retrieving an object(s) from\r\n     * the data source (as some of them may be incomplete).\r\n     *\r\n     * @param {Object} model The model that is going to have its unset\r\n     * attributes filled with \"default\" data, in case none is provided\r\n     * all of the attributes will be filled with \"default\" data.\r\n     * @param {Boolean} safe If the safe mode should be used for the fill\r\n     * operation meaning that under some conditions no unit fill\r\n     * operation is going to be applied (eg: retrieval operations).\r\n     */\r\n    static async fill(model = {}, safe = false) {\r\n        for (const [name, field] of Object.entries(this.schema)) {\r\n            if (model[name] !== undefined) continue;\r\n            if ([\"_id\"].includes(model[name])) continue;\r\n            const _private = field.private === undefined ? false : field.private;\r\n            const increment = field.increment === undefined ? false : field.increment;\r\n            if (_private && safe) continue;\r\n            if (increment) continue;\r\n            if (field.initial !== undefined) {\r\n                const initial = field.initial;\r\n                model[name] = initial;\r\n            } else {\r\n                const type = field.type || null;\r\n                let _default = typeD(type, null);\r\n                _default = type._default === undefined ? _default : type._default();\r\n                model[name] = _default;\r\n            }\r\n        }\r\n    }\r\n\r\n    static cast(name, value, safe = true) {\r\n        if (!this.schema[name]) return value;\r\n        if (value === null || value === undefined) return value;\r\n        const _definition = this.definitionN(name);\r\n        const _type = _definition.type || String;\r\n        const builder = BUILDERS[_type] || (v => new _type(v));\r\n        try {\r\n            return builder ? builder(value) : value;\r\n        } catch (err) {\r\n            if (!safe) throw err;\r\n            let _default = this.typeD[_type] || null;\r\n            _default = _type._default ? _type._default() : _default;\r\n            return _default;\r\n        }\r\n    }\r\n\r\n    static get eagers() {\r\n        return Object.entries(this.schema)\r\n            .filter(([name, field]) => field.eager)\r\n            .map(([name, field]) => name);\r\n    }\r\n\r\n    /**\r\n     * The name of the data source adapter that is going\r\n     * to be used to handle this model instance.\r\n     *\r\n     * @type {String}\r\n     */\r\n    static get adapter() {\r\n        return process.env.ADAPTER || \"mongo\";\r\n    }\r\n\r\n    async validate() {\r\n        const errors = [...this._validate()];\r\n        if (errors.length) {\r\n            throw new ValidationError(\r\n                `Invalid model: ${errors.map(err => String(err)).join(\", \")}`\r\n            );\r\n        }\r\n    }\r\n\r\n    async apply(model) {\r\n        await this.wrap(model);\r\n        return this;\r\n    }\r\n\r\n    async wrap(model) {\r\n        await this._wrap(model);\r\n        return this;\r\n    }\r\n\r\n    get isNew() {\r\n        return this._id === undefined;\r\n    }\r\n\r\n    get model() {\r\n        return this;\r\n    }\r\n\r\n    async jsonV() {\r\n        return this.model;\r\n    }\r\n\r\n    get string() {\r\n        return JSON.stringify(this.model);\r\n    }\r\n\r\n    /**\r\n     * Wraps the provided model object around the current instance, making\r\n     * sure that all of the elements are compliant with the schema.\r\n     *\r\n     * It should be possible to override the `_wrap` operation to implement\r\n     * a custom \"way\" of setting data into a model.\r\n     *\r\n     * @param {Object} model The model structure that is going to be used\r\n     * to wrap the current model object, meaning that all of its elements\r\n     * are going to be stored in the current object.\r\n     */\r\n    async _wrap(model) {\r\n        for (const key of Object.keys(this.constructor.schema)) {\r\n            const value = model[key];\r\n            if (value === undefined) continue;\r\n            this[key] = this.constructor.cast(key, value);\r\n        }\r\n        if (model._id !== undefined) this._id = model._id;\r\n    }\r\n\r\n    * _validate() {\r\n        for (const [name, value] of Object.entries(this.constructor.schema)) {\r\n            const validation = value.validation || false;\r\n            if (!validation) continue;\r\n            for (const callable of validation) {\r\n                try {\r\n                    callable(this[name]);\r\n                } catch (err) {\r\n                    yield err;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass ModelStore extends Model {\r\n    static _getAttrs(params, attrs) {\r\n        const _attrs = [];\r\n\r\n        attrs.forEach(([attr, value]) => {\r\n            if (params[attr] === undefined) {\r\n                _attrs.push(value);\r\n                return;\r\n            }\r\n\r\n            const _value = params[attr];\r\n            delete params[attr];\r\n            _attrs.push(_value);\r\n        });\r\n\r\n        return _attrs;\r\n    }\r\n\r\n    static async get(params = {}) {\r\n        /* eslint-disable no-unused-vars */\r\n        let [\r\n            fields,\r\n            eager,\r\n            eagerL,\r\n            map,\r\n            rules,\r\n            meta,\r\n            build,\r\n            fill,\r\n            resolveA,\r\n            skip,\r\n            limit,\r\n            sort,\r\n            raiseE\r\n        ] = this._getAttrs(params, [\r\n            [\"fields\", null],\r\n            [\"eager\", null],\r\n            [\"eagerL\", null],\r\n            [\"map\", false],\r\n            [\"rules\", true],\r\n            [\"meta\", false],\r\n            [\"build\", true],\r\n            [\"fill\", true],\r\n            [\"resolveA\", null],\r\n            [\"skip\", 0],\r\n            [\"limit\", 0],\r\n            [\"sort\", null],\r\n            [\"raiseE\", true]\r\n        ]);\r\n        /* eslint-enable no-unused-vars */\r\n        if (eagerL === null) eagerL = map;\r\n        if (eagerL) eager = this._eagerB(eager);\r\n\r\n        const sortObject = {};\r\n        if (sort) {\r\n            sort.forEach(([key, value]) => (sortObject[key] = value));\r\n        }\r\n\r\n        const found = await this.collection.findOne(params, this.fields, {\r\n            skip: skip,\r\n            limit: limit,\r\n            sort: sortObject\r\n        });\r\n\r\n        if (!found && raiseE) {\r\n            let message;\r\n            if (_isDevel()) {\r\n                message = `${this.name} not found for ${JSON.stringify(params)}`;\r\n            } else {\r\n                message = `${this.name} not found`;\r\n            }\r\n            throw new NotFoundError(message);\r\n        }\r\n        let model = found ? await new this().wrap(found) : found;\r\n        if (model) {\r\n            if (eager) model = await this._eager(model, eager, { map: map });\r\n        }\r\n        return model;\r\n    }\r\n\r\n    static async find(params = {}) {\r\n        /* eslint-disable no-unused-vars */\r\n        const [\r\n            fields,\r\n            eager,\r\n            eagerL,\r\n            map,\r\n            rules,\r\n            meta,\r\n            build,\r\n            fill,\r\n            resolveA,\r\n            skip,\r\n            limit,\r\n            sort,\r\n            raiseE\r\n        ] = this._getAttrs(params, [\r\n            [\"fields\", null],\r\n            [\"eager\", null],\r\n            [\"eagerL\", null],\r\n            [\"map\", false],\r\n            [\"rules\", true],\r\n            [\"meta\", false],\r\n            [\"build\", true],\r\n            [\"fill\", true],\r\n            [\"resolveA\", null],\r\n            [\"skip\", 0],\r\n            [\"limit\", 0],\r\n            [\"sort\", null],\r\n            [\"raiseE\", false]\r\n        ]);\r\n        /* eslint-enable no-unused-vars */\r\n\r\n        this._findS(params);\r\n        this._findD(params);\r\n\r\n        const sortObject = {};\r\n        if (sort) {\r\n            sort.forEach(([key, value]) => (sortObject[key] = value));\r\n        }\r\n\r\n        const found = await this.collection.find(params, this.fields, {\r\n            skip: skip,\r\n            limit: limit,\r\n            sort: sortObject\r\n        });\r\n\r\n        if (found.length === 0 && raiseE) {\r\n            let message;\r\n            if (_isDevel()) {\r\n                message = `${this.name} not found for ${JSON.stringify(params)}`;\r\n            } else {\r\n                message = `${this.name} not found`;\r\n            }\r\n            throw new NotFoundError(message);\r\n        }\r\n\r\n        const models = await Promise.all(found.map(v => new this().wrap(v)));\r\n        return models;\r\n    }\r\n\r\n    static async count(params = {}) {\r\n        let result = null;\r\n        if (Object.keys(params).length > 0) {\r\n            result = await this.collection.find(params);\r\n            result = result.length;\r\n        } else {\r\n            result = await this.collection.count();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static _findD(params) {\r\n        // retrieves the find definition into a local variable, then\r\n        // removes the find definition from the named arguments map\r\n        // so that it's not going to be erroneously used by the\r\n        // underlying find infra-structure\r\n        const findD = params.find_d;\r\n        delete params.find_d;\r\n\r\n        // in case the find definition is currently not defined in the\r\n        // named arguments map returns immediately as nothing is\r\n        // meant to be done on this method\r\n        if (!findD) return;\r\n\r\n        // tries to retrieve the value of the operator that is going\r\n        // to be used to \"join\" the multiple find parts (find values)\r\n        const findO = params.find_o;\r\n        delete params.find_o;\r\n\r\n        // verifies that the data type for the find definition is a\r\n        // valid sequence and in case its not converts it into one\r\n        // so that it may be used in sequence valid logic\r\n        const _findD = Array.isArray(findD) ? findD : [findD];\r\n\r\n        // iterates over all the filters defined in the filter definition\r\n        // so that they may be used to update the provided arguments with\r\n        // the filter defined in each of their lines\r\n        for (const filter of _findD) {\r\n            // in case the filter is not valid (unset or invalid) it's going\r\n            // to be ignored as no valid information is present\r\n            if (!filter) continue;\r\n\r\n            // splits the filter string into its three main components\r\n            // the name, operator and value, that are going to be processed\r\n            // as defined by the specification to create the filter\r\n            const result = filter.split(\":\", 3);\r\n            if (result.length === 2) result.push(null);\r\n\r\n            // unpacks the result into it's thee components name, operator\r\n            // and value to be used in the parsing of the filter\r\n            const [name, operator, value] = result;\r\n\r\n            // retrieves the definition for the filter attribute and uses\r\n            // it to retrieve it's target data type that is going to be\r\n            // used for the proper conversion, note that in case the base\r\n            // type resolution method exists it's used (recursive resolution)\r\n            const nameDefinition = this.definitionN(name);\r\n            const nameT = nameDefinition._btype || nameDefinition.type || String;\r\n\r\n            // determines if the current filter operation should be performed\r\n            // using a case insensitive based approach to the search, by default\r\n            // all of the operations are considered to be case sensitive\r\n            const insensitive = INSENSITIVE[operator] || false;\r\n\r\n            // retrieves the method that is going to be used for value mapping\r\n            // or conversion based on the current operator and then converts\r\n            // the operator into the domain specific operator\r\n            const valueMethod = VALUE_METHODS[operator];\r\n            const _operator = OPERATORS[operator] === undefined ? operator : OPERATORS[operator];\r\n\r\n            // in case there's a custom value mapped retrieved uses it to convert\r\n            // the string based value into the target specific value for the query\r\n            // otherwise uses the data type for the search field for value conversion\r\n            const _value = valueMethod ? valueMethod(value, nameT) : nameT(value);\r\n\r\n            // constructs the custom find value using a key and value map value\r\n            // in case the operator is defined otherwise (operator not defined)\r\n            // the value is used directly, then merges this find value into the\r\n            // current set of filters for the provided (keyword) arguments\r\n            let findV;\r\n            if (_operator) {\r\n                const obj = {};\r\n                obj[_operator] = _value;\r\n                findV = obj;\r\n            } else {\r\n                findV = _value;\r\n            }\r\n\r\n            if (insensitive) findV.$options = \"-i\";\r\n            this._filterMerge(name, findV, params, findO);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Working at a model map/dictionary level tries to resolve the\r\n     * relations described by the sequence of `.` separated names paths.\r\n     *\r\n     * Should be able to handle both instance and map associated eager\r\n     * loading relations.\r\n     *\r\n     * @param {Object} model The model map to be used as reference for the eager\r\n     * loading of relations.\r\n     * @param {Array} names The list of dot separated name paths to \"guide\" the\r\n     * loading of relations (references).\r\n     * @returns {Object} The resulting model with the required relations loaded.\r\n     */\r\n    static async _eager(model, names, kwargs = {}) {\r\n        // verifies if the provided model instance is a sequence and if\r\n        // that's the case runs the recursive eager loading of names and\r\n        // returns the resulting sequence to the caller method\r\n        const isList = Array.isArray(model);\r\n        if (isList) return Promise.all(model.map(_model => this._eager(_model, names, kwargs)));\r\n\r\n        // iterates over the complete set of names that are meant to be\r\n        // eager loaded from the model and runs the \"resolution\" process\r\n        // for each of them so that they are properly eager loaded\r\n        for (const name of names) {\r\n            let _model = model;\r\n            for (const part of name.split(\".\")) {\r\n                const isSequence = Array.isArray(_model);\r\n                if (isSequence) {\r\n                    _model = await Promise.all(_model.map(value => this._res(value, part, kwargs)));\r\n                } else _model = await this._res(_model, part, kwargs);\r\n                if (!_model) break;\r\n            }\r\n        }\r\n\r\n        // returns the resulting model to the caller method, most of the\r\n        // times this model should have not been touched\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Resolves a specific model part taking into account the multiple\r\n     * possible resolution strategies.\r\n     *\r\n     * Most of its logic will be associated with reference like types.\r\n     *\r\n     * This method will also (for map based resolution strategies) change\r\n     * the owner model, setting its references with the resolved maps, this\r\n     * is required as maps do not allow reference objects to exist.\r\n     *\r\n     * @param {Object} model The model map to be used in the resolution process.\r\n     * @param {String} part The name of the model's part to be resolved.\r\n     * @returns {Object} The resolved part that may be either a map or an object\r\n     * depending on the resolution strategy.\r\n     */\r\n    static async _res(model, part, kwargs = {}) {\r\n        // in case the provided is not valid returns it (no resolution is\r\n        // possible) otherwise gather the base value for resolution\r\n        if (!model) return model;\r\n        let value = model[part];\r\n\r\n        // check the data type of the requested name for resolution\r\n        // and in case it's not valid and not a reference returns it\r\n        // immediately, no resolution to be performed\r\n        const isReference = TYPE_REFERENCES.some(type => value instanceof type);\r\n        if (!value && !isReference) return value;\r\n\r\n        // in case the value is a reference type object then runs\r\n        // the resolve operation effectively resolving the values\r\n        // (this is considered a very expensive operation), notice\r\n        // that this operation is going to respect the map vs. instance\r\n        // kind of resolution process so the data type of the resulting\r\n        // value is going to depend on that\r\n        if (isReference) value = await value.resolve({ eagerL: true });\r\n\r\n        // in case the map resolution process was requested an explicit\r\n        // set of the resolved value is required (implicit resolution\r\n        // using `resolve()`) is not enough to ensure proper type structure\r\n        if (kwargs.map) model[part] = value;\r\n\r\n        // returns the \"final\" (possibly resolved) value to the caller method\r\n        // ready to be used for possible merging processes\r\n        return value;\r\n    }\r\n\r\n    static _findS(params) {\r\n        // tries to retrieve the find name value from the provided\r\n        // named arguments defaulting to an unset value otherwise\r\n        const findN = params.find_n;\r\n        delete params.find_n;\r\n\r\n        // retrieves the kind of insensitive strategy that is going\r\n        // to be used for the resolution of regular expressions,\r\n        // this should affect all the filters and so it should be\r\n        // used with some amount of care\r\n        const findI = params.find_i || false;\r\n        delete params.find_i;\r\n\r\n        // retrieves the kind of default operation to be performed\r\n        // this may be either: right, left or both and the default\r\n        // value is both so that the token is matched in case it\r\n        // appears anywhere in the search string\r\n        const findT = params.find_t || \"both\";\r\n        delete params.find_t;\r\n\r\n        // retrieves the find string into a local variable, then\r\n        // removes the find string from the named arguments map\r\n        // so that it's not going to be erroneously used by the\r\n        // underlying find infra-structure\r\n        const findS = params.find_s;\r\n        delete params.find_s;\r\n\r\n        // in case the find string is currently not defined in the\r\n        // named arguments map returns immediately as nothing is\r\n        // meant to be done on this method\r\n        if (!findS) return;\r\n\r\n        // retrieves the \"name\" of the attribute that is considered\r\n        // to be the default (representation) for the model in case\r\n        // there's none returns immediately, as it's not possible\r\n        // to proceed with the filter creation\r\n        const defaultName = findN || this.default; // TODO DEFAULT WORKS?\r\n        if (!defaultName) return;\r\n\r\n        // constructs the proper right and left parts of the regex\r\n        // that is going to be constructed for the matching of the\r\n        // value, this is achieved by checking the find type\r\n        const right = findT === \"right\" ? \"^\" : \"\";\r\n        const left = findT === \"left\" ? \"$\" : \"\";\r\n\r\n        // retrieves the definition for the default attribute and uses\r\n        // it to retrieve it's target data type, defaulting to the\r\n        // string type in case none is defined in the schema\r\n        const defaultT = this.definitionN(defaultName).type || String;\r\n\r\n        let findV;\r\n\r\n        try {\r\n            // in case the target date type for the default field is\r\n            // string the both sides wildcard regex is used for the\r\n            // search\r\n            if (defaultT === String) {\r\n                findV = {\r\n                    $regex: right + escapeStringRegexp(findS) + left,\r\n                    $options: findI ? \"-i\" : \"\"\r\n                };\r\n            } else {\r\n                findV = null;\r\n            }\r\n        } catch (err) {\r\n            // in case there's an error in the conversion for\r\n            // the target type value sets the search value as\r\n            // invalid (not going to be used in filter)\r\n            findV = null;\r\n        }\r\n\r\n        if (findV) this._filterMerge(defaultName, findV, params);\r\n    }\r\n\r\n    static get fields() {\r\n        return Object.keys(this.schema);\r\n    }\r\n\r\n    static get default() {\r\n        const defaultEntry = Object.entries(this.schema).find(\r\n            ([name, definition]) => definition.default\r\n        );\r\n        return defaultEntry ? defaultEntry[0] : null;\r\n    }\r\n\r\n    static definitionN(name) {\r\n        return this.schema[name] || {};\r\n    }\r\n\r\n    static _filterMerge(name, filter, params, operator = null) {\r\n        // retrieves a possible previous filter defined for the\r\n        // provided name in case it does exist must concatenate\r\n        // that previous value in a join statement according to\r\n        // the currently defined operator\r\n        const filterP = params[name];\r\n        if (filterP || operator) {\r\n            // defaults the operator for the join of the names to the\r\n            // value and then ensures that the value of the operator\r\n            // is within a valid range of values\r\n            const _operator = operator || \"$and\";\r\n            verify([\"$and\", \"$or\"].includes(_operator));\r\n\r\n            // retrieves the and references for the current arguments\r\n            // and appends the two filter values (current and previous)\r\n            // then deletes the current name reference in the arguments\r\n            // and updates the name value to the and value\r\n            const filterA = params[_operator] || [];\r\n\r\n            // builds the filter object assigned to the name of the\r\n            // variable and adds to the list of values\r\n            const _filter = {};\r\n            _filter[name] = filter;\r\n            filterA.push(_filter);\r\n\r\n            // in case there's a previous filter also adds it to the\r\n            // list of filter values\r\n            if (filterP) {\r\n                const _filterP = {};\r\n                _filterP[name] = filterP;\r\n                filterA.push(_filterP);\r\n            }\r\n\r\n            // updates the filter reference and updates the operator\r\n            // name (as expected)\r\n            filter = filterA;\r\n            delete params[name];\r\n            name = _operator;\r\n        }\r\n\r\n        // sets the currently defined filter structures in the keyword\r\n        // based arguments map for the currently defined name\r\n        params[name] = filter;\r\n    }\r\n\r\n    static get schema() {\r\n        throw new NotImplementedError();\r\n    }\r\n\r\n    /**\r\n     * Safer version of the schema structure that filters\r\n     * some of the field attributes making it suitable to\r\n     * be used by some of the collection adapters.\r\n     */\r\n    static get schemaSafe() {\r\n        const schema = {};\r\n        for (const [key, value] of Object.entries(this.schema)) {\r\n            schema[key] = {\r\n                type: value.type || String,\r\n                index: value.index || false\r\n            };\r\n        }\r\n        return schema;\r\n    }\r\n\r\n    static get collection() {\r\n        if (this._collectionI) return this._collectionI;\r\n        this._collectionI = this._collection(this.dataOptions);\r\n        return this._collectionI;\r\n    }\r\n\r\n    static get idName() {\r\n        return \"id\";\r\n    }\r\n\r\n    static get dataOptions() {\r\n        return {\r\n            name: this.name,\r\n            schema: this.schemaSafe\r\n        };\r\n    }\r\n\r\n    static get increments() {\r\n        if (this._increments !== undefined) return this._increments;\r\n        const increments = [];\r\n\r\n        for (const [name, value] of Object.entries(this.schema)) {\r\n            const isIncrement = value.increment || false;\r\n            if (!isIncrement) continue;\r\n            increments.push(name);\r\n        }\r\n\r\n        this._increments = increments;\r\n        return increments;\r\n    }\r\n\r\n    static _collection(options) {\r\n        const adapter = this.adapter[0].toUpperCase() + this.adapter.slice(1);\r\n        return new collection[adapter + \"Collection\"](options);\r\n    }\r\n\r\n    static async _increment(name) {\r\n        const _name = this.name + \":\" + name;\r\n        const store = this._collection({\r\n            name: \"counters\",\r\n            schema: {\r\n                id: { type: String, index: true },\r\n                seq: { type: Number }\r\n            }\r\n        });\r\n        let result = await store.findOneAndUpdate(\r\n            {\r\n                id: _name\r\n            },\r\n            {\r\n                $inc: {\r\n                    seq: 1\r\n                }\r\n            },\r\n            {\r\n                new: true,\r\n                upsert: true\r\n            }\r\n        );\r\n        result = result || (await store.findOne({ id: _name }));\r\n        return result.seq;\r\n    }\r\n\r\n    static async _ensureMin(name, value) {\r\n        const _name = this.name + \":\" + name;\r\n        const store = this._collection({\r\n            name: \"counters\",\r\n            schema: {\r\n                id: { type: String },\r\n                seq: { type: Number }\r\n            }\r\n        });\r\n        let result = await store.findOneAndUpdate(\r\n            {\r\n                id: _name\r\n            },\r\n            {\r\n                $max: {\r\n                    seq: value\r\n                }\r\n            },\r\n            {\r\n                new: true,\r\n                upsert: true\r\n            }\r\n        );\r\n        result = result || (await store.findOne({ id: _name }));\r\n        return result.seq;\r\n    }\r\n\r\n    /**\r\n     * Builds the provided list of eager values, preparing them\r\n     * according to the current model rules.\r\n     *\r\n     * The composition process includes the extension of the provided\r\n     * sequence of eager values with the base ones defined in the\r\n     * model, if not handled correctly this is an expensive operation.\r\n     *\r\n     * @param {Array} eager The base sequence containing the various fields\r\n     * that should be eagerly loaded for the operation.\r\n     * @returns {Array} The \"final\" resolved array that may be used for the eager\r\n     * loaded operation performance.\r\n     */\r\n    static _eagerB(eager) {\r\n        eager = eager || [];\r\n        eager = Array.isArray(eager) ? eager : [eager];\r\n        eager.push(...this.eagers);\r\n        if (eager.length === 0) return eager;\r\n        eager = [...new Set(eager)];\r\n        return eager;\r\n    }\r\n\r\n    async save({\r\n        validate = true,\r\n        incrementA = undefined,\r\n        immutablesA = undefined,\r\n        preSave = true,\r\n        preCreate = true,\r\n        preUpdate = true,\r\n        postSave = true,\r\n        postCreate = true,\r\n        postUpdate = true,\r\n        beforeCallbacks = [],\r\n        afterCallbacks = []\r\n    } = {}) {\r\n        // in case the validate flag is set runs the model validation\r\n        // defined for the current model\r\n        if (validate) await this.validate();\r\n\r\n        // calls the complete set of event handlers for the current\r\n        // save operation, this should trigger changes in the model\r\n        if (preSave) await this.preSave();\r\n        if (preCreate) await this.preCreate();\r\n        if (preUpdate) await this.preUpdate();\r\n\r\n        // filters the values that are present in the current model\r\n        // so that only the valid ones are stored in, invalid values\r\n        // are going to be removed, note that if the operation is an\r\n        // update operation and the \"immutable rules\" also apply, the\r\n        // returned value is normalized meaning that for instance if\r\n        // any relation is loaded the reference value is returned instead\r\n        // of the loaded relation values (required for persistence)\r\n        let model = await this._filter({\r\n            incrementA: incrementA,\r\n            immutablesA: immutablesA,\r\n            normalize: true\r\n        });\r\n\r\n        // runs the lower layer integrity verifications that should raise\r\n        // exception in case there's a failure\r\n        await this.verify(model);\r\n\r\n        // calls the complete set of callbacks that should be called\r\n        // before the concrete data store save operation\r\n        for (const callback of beforeCallbacks) {\r\n            await callback(this, this.model);\r\n        }\r\n\r\n        // verifies if the current model is a new one or if instead\r\n        // represents an update to a previously stored model and create\r\n        // or update data accordingly\r\n        const isNew = this._id === undefined;\r\n        if (isNew) {\r\n            model = await this.constructor.collection.create(model);\r\n        } else {\r\n            const conditions = {};\r\n            conditions[this.constructor.idName] = this.identifier;\r\n            model = await this.constructor.collection.findOneAndUpdate(conditions, model);\r\n        }\r\n\r\n        // wraps the model object using the current instance\r\n        // effectively making the data available for consumers\r\n        this.wrap(model);\r\n\r\n        // calls the complete set of callbacks that should be called\r\n        // after the concrete data store save operation\r\n        for (const callback of afterCallbacks) {\r\n            await callback(this, this.model);\r\n        }\r\n\r\n        // calls the post save event handlers in order to be able to\r\n        // execute appropriate post operations\r\n        if (postSave) await this.postSave();\r\n        if (postCreate) await this.postCreate();\r\n        if (postUpdate) await this.postUpdate();\r\n\r\n        return this;\r\n    }\r\n\r\n    async delete({\r\n        preDelete = true,\r\n        postDelete = true,\r\n        beforeCallbacks = [],\r\n        afterCallbacks = []\r\n    } = {}) {\r\n        // calls the complete set of event handlers for the current\r\n        // delete operation, this should trigger changes in the model\r\n        if (preDelete) await this.preDelete();\r\n\r\n        // calls the complete set of callbacks that should be called\r\n        // before the concrete data store delete operation\r\n        for (const callback of beforeCallbacks) {\r\n            await callback(this, this.model);\r\n        }\r\n\r\n        // builds the set of conditions that rare going to be used for\r\n        // the concrete delete operation to be performed\r\n        const conditions = {};\r\n        conditions[this.constructor.idName] = this.identifier;\r\n        await this.constructor.collection.findOneAndDelete(conditions);\r\n\r\n        // calls the complete set of callbacks that should be called\r\n        // after the concrete data store delete operation\r\n        for (const callback of afterCallbacks) {\r\n            await callback(this, this.model);\r\n        }\r\n\r\n        // calls the complete set of event handlers for the current\r\n        // delete operation, this should trigger changes in the model\r\n        if (postDelete) await this.postDelete();\r\n\r\n        return this;\r\n    }\r\n\r\n    async advance(name, delta = 1) {\r\n        const conditions = {};\r\n        conditions[this.constructor.idName] = this.identifier;\r\n        const increments = {};\r\n        increments[name] = delta;\r\n        let value = await this.constructor.collection.findOneAndUpdate(\r\n            conditions,\r\n            {\r\n                $inc: increments\r\n            },\r\n            {\r\n                new: true\r\n            }\r\n        );\r\n        value = value || (await this.constructor.collection.find_one(conditions));\r\n        const _value = value[name];\r\n        this[name] = _value;\r\n        return _value;\r\n    }\r\n\r\n    async reload(params = {}) {\r\n        if (this.isNew) {\r\n            throw new OperationalError(\"Can't reload a new model entity\", 412);\r\n        }\r\n        const model = await this.constructor.get({ ...params, _id: this._id });\r\n        return model;\r\n    }\r\n\r\n    /**\r\n     * Runs a series of assertions on the current model\r\n     * definition raising assertion errors in case there\r\n     * are issues with the internal structure of it.\r\n     *\r\n     * @param {Object} model The model that is going to\r\n     * be verified for a series of elements.\r\n     */\r\n    async verify(model) {\r\n        verify(\r\n            this.getIdentifier(model) !== undefined && this.getIdentifier(model) !== null,\r\n            \"The identifier must be defined before saving\",\r\n            400,\r\n            OperationalError\r\n        );\r\n        for (const [name, field] of Object.entries(this.constructor.schema)) {\r\n            verify(\r\n                !field.required || ![undefined, null].includes(model[name]),\r\n                `No value provided for mandatory field '${name}'`,\r\n                400,\r\n                OperationalError\r\n            );\r\n        }\r\n    }\r\n\r\n    async preSave() {}\r\n\r\n    async preCreate() {}\r\n\r\n    async preUpdate() {}\r\n\r\n    async preDelete() {}\r\n\r\n    async postSave() {}\r\n\r\n    async postCreate() {}\r\n\r\n    async postUpdate() {}\r\n\r\n    async postDelete() {}\r\n\r\n    async _filter({\r\n        incrementA = true,\r\n        immutablesA = true,\r\n        normalize = false,\r\n        resolve = false,\r\n        all = false,\r\n        evaluator = \"jsonV\"\r\n    } = {}) {\r\n        const model = {};\r\n\r\n        // iterates over each of the fields that are meant to have its value\r\n        // increment and performs the appropriate operation taking into account\r\n        // if the value is already populated or not\r\n        for (const name of this.constructor.increments) {\r\n            if (incrementA === false) continue;\r\n            const exists = this.model[name] !== undefined;\r\n            if (exists) {\r\n                model[name] = await this.constructor._ensureMin(name, this.model[name]);\r\n            } else {\r\n                model[name] = await this.constructor._increment(name);\r\n            }\r\n        }\r\n\r\n        // iterates over all the model items to filter the ones\r\n        // that are not valid for the current class context\r\n        await Promise.all(\r\n            Object.entries(this.model).map(async ([name, value]) => {\r\n                if (this.constructor.schema[name] === undefined) return;\r\n                // if (immutablesA && this.immutables[name] !== undefined) return;\r\n                model[name] = await this._evaluate(name, value, evaluator);\r\n            })\r\n        );\r\n\r\n        // in case the normalize flag is set must iterate over all\r\n        // items to try to normalize the values by calling the reference\r\n        // value this will returns the reference index value instead of\r\n        // the normal value that would prevent normalization\r\n        if (normalize) {\r\n            await Promise.all(\r\n                Object.entries(this.model).map(async ([name, value]) => {\r\n                    if (this.constructor.schema[name] === undefined) return;\r\n                    if (!value || !value.refV) return;\r\n                    model[name] = await value.refV();\r\n                })\r\n            );\r\n        }\r\n\r\n        // in case the resolution flag is set, it means that a recursive\r\n        // approach must be performed for the resolution of values that\r\n        // implement the map value (recursive resolution) method, this is\r\n        // a complex (and possible computational expensive) process that\r\n        // may imply access to the base data source\r\n        if (resolve) {\r\n            throw new NotImplementedError(\"'resolve' not implemented\");\r\n        }\r\n\r\n        // in case the all flag is set the extra fields (not present\r\n        // in definition) must also be used to populate the resulting\r\n        // (filtered) map so that it contains the complete set of values\r\n        // present in the base map of the current instance\r\n        if (all) {\r\n            throw new NotImplementedError(\"'all' not implemented\");\r\n        }\r\n\r\n        // returns the model containing the \"filtered\" items resulting\r\n        // from the validation of the items against the model class\r\n        return model;\r\n    }\r\n\r\n    async _evaluate(name, value, evaluator = \"jsonV\") {\r\n        // verifies if the current value is an iterable one in case\r\n        // it is runs the evaluate method for each of the values to\r\n        // try to resolve them into the proper representation, note\r\n        // that both base iterable values (lists and dictionaries) and\r\n        // objects that implement the evaluator method are not considered\r\n        // to be iterables and normal operation applies\r\n        let isIterable;\r\n        try {\r\n            isIterable = Boolean((value && value.items) || Array.isArray(value));\r\n        } catch (error) {\r\n            // AttributeErrors are tolerated since they might simply\r\n            // represent a missing \"items\" field when dealing with\r\n            // references\r\n            if (!(error instanceof AttributeError)) throw error;\r\n            isIterable = false;\r\n        }\r\n\r\n        const hasEvaluator = Boolean(\r\n            evaluator && (Array.isArray(value) ? value.length : value) && value[evaluator]\r\n        );\r\n        isIterable = isIterable && !hasEvaluator;\r\n        if (isIterable) {\r\n            const result = await Promise.all(\r\n                (value.items || value).map(item => this._evaluate(name, item, evaluator))\r\n            );\r\n            return result;\r\n        }\r\n\r\n        // verifies the current value's class is sub class of the model\r\n        // class and in case it's extracts the relation name from the\r\n        // value and sets it as the value in iteration\r\n        const isModel = value instanceof Model;\r\n        if (isModel) {\r\n            const meta = this.constructor.definitionN(name);\r\n            const type = meta.type || String;\r\n            const _name = type._name;\r\n            value = value[_name];\r\n        }\r\n\r\n        // iterates over all the values and retrieves the map value for\r\n        // each of them in case the value contains a map value retrieval\r\n        // method otherwise uses the normal value returning it to the caller\r\n        const method = hasEvaluator ? value[evaluator] : null;\r\n        value = method ? await method.bind(value)(false) : value;\r\n        return value;\r\n    }\r\n\r\n    getIdentifier(model) {\r\n        return model[this.constructor.idName];\r\n    }\r\n\r\n    get identifier() {\r\n        return this.getIdentifier(this.model);\r\n    }\r\n}\r\n\r\nclass ModelMemory extends ModelStore {\r\n    static get adapter() {\r\n        return \"memory\";\r\n    }\r\n\r\n    static get dataOptions() {\r\n        return Object.assign(super.dataOptions, { storage: this.storage });\r\n    }\r\n\r\n    static get storage() {\r\n        return MEMORY_STORAGE[this.name];\r\n    }\r\n}\r\n\r\n/**\r\n * Retrieves the default (initial) value for the a certain\r\n * provided data type falling back to the provided default\r\n * value in case it's not possible to retrieve a new valid\r\n *  default for value for the type.\r\n *\r\n * The process of retrieval of the default value to a certain\r\n * type may include the calling of a lambda function to obtain\r\n * a new instance of the default value, this avoid the usage\r\n * of global shared structures for the default values, that\r\n * could cause extremely confusing situations.\r\n *\r\n * @param {Type} type The data type object for which to retrieve its\r\n * default value.\r\n * @param {Object} _default The default value to be returned in case it's\r\n * not possible to retrieve a better one.\r\n * @returns {Object} The \"final\" default value for the data type according\r\n * to the best possible strategy.\r\n */\r\nconst typeD = function(type, _default = null) {\r\n    if (TYPE_DEFAULTS[type] === undefined) return _default;\r\n    _default = TYPE_DEFAULTS[type];\r\n    if (typeof _default !== \"function\") return _default;\r\n    return _default();\r\n};\n\nconst ensureExpress = token => {\r\n    return (req, res, next) => {\r\n        ensurePermissions(token, req).catch(next).then(next);\r\n    };\r\n};\n\nconst yoniusRollup = function() {\r\n    return {\r\n        name: \"yonius\",\r\n        resolveId: function(importee) {\r\n            switch (importee) {\r\n                case \"fs\":\r\n                case \"node-fetch\":\r\n                    return importee;\r\n                default:\r\n                    return null;\r\n            }\r\n        },\r\n        load: function(id) {\r\n            switch (id) {\r\n                case \"fs\":\r\n                    return \"export const promises = {};\";\r\n                case \"node-fetch\":\r\n                    return \"export default fetch;\";\r\n                default:\r\n                    return null;\r\n            }\r\n        }\r\n    };\r\n};\n\nconst NAME = name;\r\nconst VERSION = version;\n\nexport { ALIAS, API, AttributeError, Collection, FIND_DEFAULTS, FIND_TYPES, FileTuple, INSENSITIVE, MixinBuilder, Model, ModelMemory, ModelStore, MongoCollection, NAME, NotFoundError, NotImplementedError, OAuth1API, OAuth2API, OAuthAPI, OPERATORS, Observable, OperationalError, Reference, References, SORT_MAP, VALUE_METHODS, VERSION, ValidationError, YoniusError, _castR, _isDevel, _isSecure, _isValid, absoluteUrl, all, buildGetAgent, camelToUnderscore, conf, confP, confS, destroyMongo, ensureExpress, ensurePermissions, eq, equal, escapeStringRegexp, expandUser, getEnv, getEnvObject, getObject, globals, gt, gte, hasPermission, initMongo, isEmail, isIn, isLower, isPrimitive, isRegex, isSimple, isUpper, isUrl, load, load$1 as loadConf, mix, notEmpty, patchAgent, pathExists, reference, references, register, request, sizeRoundUnit, stringEq, stringGt, stringLt, toTokensM, typeD, typeof_, underscoreToCamel, unload, unregister, urlEncode, verify, verifyEqual, verifyMany, verifyNotEqual, yoniusRollup };\n//# sourceMappingURL=yonius.esm.js.map\n","/**\r\n * Option type for access point search.\r\n */\r\nexport const ACCESS_POINT_SEARCH = \"64\";\r\n\r\n/**\r\n * Option type to sort by closest in search.\r\n */\r\nexport const CLOSEST_POINT_SEARCH = \"01\";\r\n\r\nexport const LocatorAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Finds the nearest UPS Access Point to a given address.\r\n         *\r\n         * @param {String} addressLine The address from where the distance is measured.\r\n         * @param {String} city The city from where the distance is measured.\r\n         * @param {String} postalCode The postalCode from where the distance is measured.\r\n         * @param {String} countryCode The countryCode from where the distance is measured.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async getNearestAccessPoint(addressLine, city, postalCode, countryCode, options = {}) {\r\n            const url = `${this.baseUrl}locations/${this.version}/search/availabilities/${ACCESS_POINT_SEARCH}`;\r\n            const payload = this._buildNearestAccessPointPayload(\r\n                addressLine,\r\n                city,\r\n                postalCode,\r\n                countryCode,\r\n                options\r\n            );\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: payload\r\n            });\r\n            return response;\r\n        }\r\n\r\n        _buildNearestAccessPointPayload(\r\n            addressLine,\r\n            city,\r\n            postalCode,\r\n            countryCode,\r\n            { consignee = null, locale = \"en_US\", metric = true, radius = 150 } = {}\r\n        ) {\r\n            const payload = {\r\n                LocatorRequest: {\r\n                    Request: {\r\n                        RequestAction: \"Locator\",\r\n                        RequestOption: ACCESS_POINT_SEARCH\r\n                    },\r\n                    OriginAddress: {\r\n                        AddressKeyFormat: {\r\n                            ConsigneeName: consignee,\r\n                            AddressLine: addressLine,\r\n                            PoliticalDivision2: city,\r\n                            PostcodePrimaryLow: postalCode,\r\n                            CountryCode: countryCode\r\n                        }\r\n                    },\r\n                    Translate: {\r\n                        Locale: locale\r\n                    },\r\n                    UnitOfMeasurement: { Code: metric ? \"KM\" : \"MI\" },\r\n                    SortCriteria: { SortType: CLOSEST_POINT_SEARCH }\r\n                }\r\n            };\r\n            return payload;\r\n        }\r\n    };\r\n","export const SMALL_PACKAGE_SHIPMENT_TYPE = \"1\";\r\nexport const FREIGHT_SHIPMENT_TYPE = \"2\";\r\n\r\nexport const AUTH_FORM_DOC_TYPE = \"001\";\r\nexport const INVOICE_DOC_TYPE = \"002\";\r\nexport const CERTIFICATE_ORIGIN_DOC_TYPE = \"003\";\r\nexport const EXPORT_ACCOMPANYING_DOC_TYPE = \"004\";\r\nexport const EXPORT_LICENSE_DOC_TYPE = \"005\";\r\nexport const IMPORT_PERMIT_DOC_TYPE = \"006\";\r\nexport const ONE_TIME_NAFTA_DOC_TYPE = \"007\";\r\nexport const OTHER_DOC_TYPE = \"008\";\r\nexport const POWER_ATTORNEY_DOC_TYPE = \"009\";\r\nexport const PACKING_LIST_DOC_TYPE = \"010\";\r\nexport const SED_DOC_TYPE = \"011\";\r\nexport const LETTER_INSTRUCTION_DOC_TYPE = \"012\";\r\nexport const DECLARATION_DOC_TYPE = \"013\";\r\n\r\nexport const PaperlessAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Uploads a document to the UPS servers.\r\n         * The uploaded document is returned and its ID can be\r\n         * used to associate a shipment with the document.\r\n         *\r\n         * @param {Object} payload The payload object according to the UPS API standards.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async createDocument(payload, options = {}) {\r\n            const url = `${this.baseUrl}paperlessdocuments/${this.version}/upload`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: { UploadRequest: payload }\r\n            });\r\n            return response;\r\n        }\r\n\r\n        /**\r\n         * Adds the already uploaded documents in the UPS servers to an\r\n         * existing shipment.\r\n         *\r\n         * @param {Object} payload The payload object according to the UPS API standards.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async addDocumentShipment(payload, options = {}) {\r\n            const url = `${this.baseUrl}paperlessdocuments/${this.version}/image`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: { PushToImageRepositoryRequest: payload }\r\n            });\r\n            return response;\r\n        }\r\n    };\r\n","export const PickupAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Schedules a pickup for a parcel.\r\n         *\r\n         * @param {Object} payload The payload object according to the UPS API standards.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async schedulePickup(payload, options = {}) {\r\n            const url = `${this.baseUrl}pickupcreation/${this.version}/pickup`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: { PickupCreationRequest: payload }\r\n            });\r\n            return response;\r\n        }\r\n    };\r\n","/*\r\n * The code representing an express shipment.\r\n */\r\nexport const EXPRESS_SERVICE_CODE = \"007\";\r\n\r\n/*\r\n * The code representing a standard shipment.\r\n */\r\nexport const STANDARD_SERVICE_CODE = \"011\";\r\n\r\n/*\r\n * The code representing a saver shipment.\r\n */\r\nexport const SAVER_SERVICE_CODE = \"065\";\r\n\r\n/*\r\n * The code representing a shipment transportation charges.\r\n */\r\nexport const TRANSPORTATION_CHARGE_TYPE = \"01\";\r\n\r\n/*\r\n * The code representing a shipment duties and taxes charges.\r\n */\r\nexport const DUTIES_CHARGE_TYPE = \"02\";\r\n\r\n/**\r\n * The code representing a customer box\r\n * package.\r\n */\r\nexport const CUSTOMER_BOX_PACKAGING_TYPE = \"02\";\r\n\r\n/**\r\n * The code representing a padded box\r\n * package.\r\n */\r\nexport const PAK_BOX_PACKAGING_TYPE = \"03\";\r\n\r\n/**\r\n * The code representing an express box\r\n * package.\r\n */\r\nexport const EXPRESS_BOX_PACKAGING_TYPE = \"21\";\r\n\r\n/**\r\n * Represents kilograms.\r\n */\r\nexport const KGS_TYPE = \"KGS\";\r\n\r\n/**\r\n * Represents pounds.\r\n */\r\nexport const LBS_TYPE = \"LBS\";\r\n\r\n/**\r\n * The code for a shipment to hold at an UPS Access Point.\r\n */\r\nexport const SHIPMENT_HOLD_ACCESS_POINT = \"01\";\r\n\r\n/**\r\n * The code for the PRL UPS return service.\r\n */\r\nexport const RETURN_PRL = \"9\";\r\n\r\n/**\r\n * The code to send an in transit email notification.\r\n */\r\nexport const NOTIFY_IN_TRANSIT = \"5\";\r\n\r\n/**\r\n * The code to send a package shipped email notification.\r\n */\r\nexport const NOTIFY_SHIP = \"6\";\r\n\r\n/**\r\n * The code to send exception email notifications.\r\n */\r\nexport const NOTIFY_EXCEPTION = \"7\";\r\n\r\n/**\r\n * The code to send a package delivered email notification.\r\n */\r\nexport const NOTIFY_DELIVERY = \"8\";\r\n\r\n/**\r\n * The code to send a delivery email notification when the package is at the Access Point.\r\n */\r\nexport const NOTIFY_ACCESS_POINT_DELIVERY = \"012\";\r\n\r\n/**\r\n * The code for a purchase order code value to\r\n * be used in reference number specification.\r\n */\r\nexport const PURCHASE_ORDER = \"PO\";\r\n\r\n/**\r\n * The code for a production code code value to\r\n * be used in reference number specification.\r\n */\r\nexport const PRODUCTION_CODE = \"PC\";\r\n\r\n/**\r\n * The code for reason for export.\r\n */\r\nexport const REASON_FOR_EXPORT = {\r\n    SALE: \"SALE\",\r\n    GIFT: \"GIFT\",\r\n    SAMPLE: \"SAMPLE\",\r\n    RETURN: \"RETURN\",\r\n    REPAIR: \"REPAIR\",\r\n    INTERCOMPANY_DATA: \"INTERCOMPANYDATA\",\r\n    ANY: \"Any other reason\"\r\n};\r\n\r\n/**\r\n * The code for form types to be used in international shipping.\r\n */\r\nexport const INTERNATIONAL_FORM_TYPE = {\r\n    USER_CREATED_FORM: \"07\",\r\n    FULL_INVOICE: \"01\"\r\n};\r\n\r\nexport const ShipmentAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Creates a shipment and associated UPS waybill.\r\n         *\r\n         * @param {Object} payload The payload object according to the UPS API standards.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async createShipment(payload, options = {}) {\r\n            const url = `${this.baseUrl}shipments/${this.version}/ship`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: { ShipmentRequest: payload }\r\n            });\r\n            return response;\r\n        }\r\n\r\n        /**\r\n         * Cancels (voids) an existing shipment and associated UPS waybill.\r\n         *\r\n         * @param {String} trackingNumber The tracking number of the shipment/waybill.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async cancelShipment(trackingNumber, options = {}) {\r\n            const url = `${this.baseUrl}shipments/${this.version}/void/cancel/${trackingNumber}`;\r\n            const response = await this.delete(url, options);\r\n            return response;\r\n        }\r\n\r\n        /**\r\n         * Gets the waybill for an existing shipment.\r\n         *\r\n         * @param {String} trackingNumber The tracking number of the shipment/waybill.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async getWaybill(trackingNumber, { format = \"pdf\", ...options } = {}) {\r\n            const url = `${this.baseUrl}labels/${this.version}/recovery`;\r\n            const response = await this.post(url, {\r\n                ...options,\r\n                dataJ: {\r\n                    LabelRecoveryRequest: {\r\n                        TrackingNumber: String(trackingNumber),\r\n                        LabelSpecification: {\r\n                            LabelImageFormat: {\r\n                                Code: format.toUpperCase()\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            return response;\r\n        }\r\n    };\r\n","/**\r\n * Shipment was picked up.\r\n */\r\nexport const STATUS_PICKUP = \"P\";\r\n\r\n/**\r\n * Shipment out for delivery.\r\n */\r\nexport const STATUS_OUT_FOR_DELIVERY = \"O\";\r\n\r\n/**\r\n * Shipment in transit.\r\n */\r\nexport const STATUS_IN_TRANSIT = \"I\";\r\n\r\n/**\r\n * Shipment exception.\r\n */\r\nexport const STATUS_EXCEPTION = \"X\";\r\n\r\n/**\r\n * Shipment delivered.\r\n */\r\nexport const STATUS_DELIVERED = \"D\";\r\n\r\n/**\r\n * Shipment returned to shipper.\r\n */\r\nexport const STATUS_RETURNED = \"RS\";\r\n\r\nexport const TrackingAPI = superclass =>\r\n    class extends superclass {\r\n        /**\r\n         * Gets the tracking information for an existing shipment.\r\n         *\r\n         * @param {String} trackingNumber The tracking number of the shipment/waybill.\r\n         * @param {Object} options An object of options to configure the request.\r\n         * @returns {Object} The HTTP response object.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        async getTrackingDetails(trackingNumber, options = {}) {\r\n            const url = `${this.baseUrl}track/${this.version}/details/${trackingNumber}`;\r\n            const response = await this.get(url, options);\r\n            return response;\r\n        }\r\n\r\n        /**\r\n         * Gets the tracking URL given a tracking number.\r\n         *\r\n         * @param {String} trackingNumber The tracking number of the shipment/waybill.\r\n         * @returns {String} The tracking URL.\r\n         * @see https://www.ups.com/upsdeveloperkit?loc=en_US\r\n         */\r\n        getTrackingUrl(trackingNumber) {\r\n            return `https://www.ups.com/track?InquiryNumber1=${trackingNumber}`;\r\n        }\r\n    };\r\n","import { API as BaseAPI, OperationalError, mix, load, conf } from \"yonius\";\r\n\r\nimport { LocatorAPI } from \"./locator\";\r\nimport { PaperlessAPI } from \"./paperless\";\r\nimport { PickupAPI } from \"./pickup\";\r\nimport { ShipmentAPI } from \"./shipment\";\r\nimport { TrackingAPI } from \"./tracking\";\r\n\r\n/**\r\n * The base auth URL used for the OAuth token request.\r\n */\r\nconst AUTH_URL = \"https://onlinetools.ups.com/\";\r\n\r\n/**\r\n * The base URL used for API requests.\r\n */\r\nconst BASE_URL = \"https://onlinetools.ups.com/api/\";\r\n\r\n/**\r\n * The version of the API to use.\r\n */\r\nconst API_VERSION = \"v1\";\r\n\r\n/**\r\n * The application grant type to obtain the token.\r\n */\r\nconst GRANT_TYPE = \"client_credentials\";\r\n\r\nexport class API extends mix(BaseAPI).with(\r\n    LocatorAPI,\r\n    PaperlessAPI,\r\n    PickupAPI,\r\n    ShipmentAPI,\r\n    TrackingAPI\r\n) {\r\n    constructor(kwargs = {}) {\r\n        super(kwargs);\r\n\r\n        this.authUrl = conf(\"UPS_AUTH_URL\", AUTH_URL);\r\n        this.baseUrl = conf(\"UPS_BASE_URL\", BASE_URL);\r\n        this.version = conf(\"UPS_API_VERSION\", API_VERSION);\r\n        this.clientId = conf(\"UPS_CLIENT_ID\", null);\r\n        this.clientSecret = conf(\"UPS_CLIENT_SECRET\", null);\r\n        this.grantType = conf(\"UPS_GRANT_TYPE\", GRANT_TYPE);\r\n        this.token = conf(\"UPS_TOKEN\", null);\r\n        this.transactionSrc = conf(\"UPS_TRANSACTION_SRC\", null);\r\n\r\n        this.authUrl = kwargs.authUrl === undefined ? this.authUrl : kwargs.authUrl;\r\n        this.baseUrl = kwargs.baseUrl === undefined ? this.baseUrl : kwargs.baseUrl;\r\n        this.version = kwargs.version === undefined ? this.version : kwargs.version;\r\n        this.clientId = kwargs.clientId === undefined ? this.clientId : kwargs.clientId;\r\n        this.clientSecret =\r\n            kwargs.clientSecret === undefined ? this.clientSecret : kwargs.clientSecret;\r\n        this.token = kwargs.token === undefined ? this.token : kwargs.token;\r\n        this.transactionSrc =\r\n            kwargs.transactionSrc === undefined ? this.transactionSrc : kwargs.transactionSrc;\r\n    }\r\n\r\n    static async load() {\r\n        await load();\r\n    }\r\n\r\n    async build(method, url, options = {}) {\r\n        await super.build(method, url, options);\r\n\r\n        if (this.token) options.headers.Authorization = this._bearerAuth();\r\n\r\n        const transactionSrc = options.headers.transactionSrc || this.transactionSrc;\r\n        if (transactionSrc) options.headers.transactionSrc = transactionSrc;\r\n\r\n        // add some fields to the header that UPS requires\r\n        if(!options.headers.transId) options.headers.transId = this.makeid(14)\r\n        if(!options.headers.transactionSrc) options.headers.transactionSrc = 'DEFAULT'\r\n        \r\n    }\r\n    \r\n    makeid(len){\r\n        var result           = '';\r\n        var char       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        var charLen = char.length;\r\n        for ( var i = 0; i < len; i++ ) {\r\n            result += char.charAt(Math.floor(Math.random() * \r\n            charLen));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    async authCallback(params, headers) {\r\n        // forces the refetch of the authorization\r\n        // token from the auth API\r\n        this.token = null;\r\n        await this.getToken();\r\n    }\r\n\r\n    async getToken() {\r\n        if (this.token) return this.token;\r\n\r\n        const url = `${this.authUrl}security/${this.version}/oauth/token`;\r\n        const data = `grant_type=${this.grantType}`;\r\n        const options = {\r\n            headers: {\r\n                Authorization: this._basicAuth()\r\n            },\r\n            data: data,\r\n            mime: \"application/x-www-form-urlencoded\"\r\n        };\r\n\r\n        const contents = await this.post(url, options);\r\n        this.token = contents.access_token;\r\n\r\n        return this.token;\r\n    }\r\n\r\n    async _handleResponse(response, errorMessage = \"Problem in request\") {\r\n        const result = await this._getResult(response);\r\n        if (!response.ok) {\r\n            let error = null;\r\n            try {\r\n                error = JSON.stringify(result);\r\n            } catch {\r\n                error = errorMessage;\r\n            }\r\n            throw new OperationalError(error, response.status || 500);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Obtains the response object from the provided response making sure that the\r\n     * content type is respected when doing so.\r\n     *\r\n     * @param {Response} response The HTTP response resulting from the request\r\n     * made by the API client\r\n     * @returns {Object|String|Blob} The parsed result value for the provided\r\n     * response object taking into account the content type of it.\r\n     */\r\n    async _getResult(response) {\r\n        let result = null;\r\n        if (\r\n            response.headers.get(\"content-type\") &&\r\n            response.headers.get(\"content-type\").toLowerCase().startsWith(\"application/json\")\r\n        ) {\r\n            result = await response.json();\r\n        } else if (\r\n            response.headers.get(\"content-type\") &&\r\n            response.headers.get(\"content-type\").toLowerCase().startsWith(\"text/\")\r\n        ) {\r\n            result = await response.text();\r\n        } else {\r\n            result = await response.blob();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    _basicAuth() {\r\n        const auth = Buffer.from(`${this.clientId}:${this.clientSecret}`).toString(\"base64\");\r\n        return `Basic ${auth}`;\r\n    }\r\n\r\n    _bearerAuth() {\r\n        return `Bearer ${this.token}`;\r\n    }\r\n}\r\n"],"names":["global","self","window","defaultSetTimout","Error","defaultClearTimeout","cachedSetTimeout","cachedClearTimeout","setTimeout","clearTimeout","runTimeout","fun","e","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","platform","browser","env","argv","version","versions","release","config","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","performance","performanceNow","now","mozNow","msNow","oNow","webkitNow","Date","getTime","hrtime","previousTimestamp","clocktime","seconds","Math","floor","nanoseconds","startTime","uptime","currentTime","dif","browser$1","normalizeArray","parts","allowAboveRoot","up","last","splice","unshift","splitPathRe","splitPath","filename","exec","slice","resolve","resolvedPath","resolvedAbsolute","path","TypeError","charAt","filter","split","p","join","normalize","isPathAbsolute","isAbsolute","trailingSlash","substr","paths","index","dirname","result","root","xs","f","res","str","start","Observable","_classCallCheck","callbacks","_createClass","key","value","bind","event","callback","unbind","indexOf","trigger","results","_iterator","_createForOfIteratorHelper","_step","s","n","done","ACCESS_POINT_SEARCH","CLOSEST_POINT_SEARCH","LocatorAPI","superclass","_superclass","_class","_callSuper","_inherits","_getNearestAccessPoint","_asyncToGenerator","_regeneratorRuntime","mark","_callee","addressLine","city","postalCode","countryCode","options","url","payload","response","_args","wrap","_callee$","_context","prev","next","undefined","baseUrl","_buildNearestAccessPointPayload","post","_objectSpread","dataJ","sent","abrupt","stop","getNearestAccessPoint","_x","_x2","_x3","_x4","_ref","_ref$consignee","consignee","_ref$locale","locale","_ref$metric","metric","radius","LocatorRequest","Request","RequestAction","RequestOption","OriginAddress","AddressKeyFormat","ConsigneeName","AddressLine","PoliticalDivision2","PostcodePrimaryLow","CountryCode","Translate","Locale","UnitOfMeasurement","Code","SortCriteria","SortType","SMALL_PACKAGE_SHIPMENT_TYPE","FREIGHT_SHIPMENT_TYPE","AUTH_FORM_DOC_TYPE","INVOICE_DOC_TYPE","CERTIFICATE_ORIGIN_DOC_TYPE","EXPORT_ACCOMPANYING_DOC_TYPE","EXPORT_LICENSE_DOC_TYPE","IMPORT_PERMIT_DOC_TYPE","ONE_TIME_NAFTA_DOC_TYPE","OTHER_DOC_TYPE","POWER_ATTORNEY_DOC_TYPE","PACKING_LIST_DOC_TYPE","SED_DOC_TYPE","LETTER_INSTRUCTION_DOC_TYPE","DECLARATION_DOC_TYPE","PaperlessAPI","_createDocument","UploadRequest","createDocument","_addDocumentShipment","_callee2","_args2","_callee2$","_context2","PushToImageRepositoryRequest","addDocumentShipment","PickupAPI","_schedulePickup","PickupCreationRequest","schedulePickup","EXPRESS_SERVICE_CODE","STANDARD_SERVICE_CODE","SAVER_SERVICE_CODE","TRANSPORTATION_CHARGE_TYPE","DUTIES_CHARGE_TYPE","CUSTOMER_BOX_PACKAGING_TYPE","PAK_BOX_PACKAGING_TYPE","EXPRESS_BOX_PACKAGING_TYPE","KGS_TYPE","LBS_TYPE","SHIPMENT_HOLD_ACCESS_POINT","RETURN_PRL","NOTIFY_IN_TRANSIT","NOTIFY_SHIP","NOTIFY_EXCEPTION","NOTIFY_DELIVERY","NOTIFY_ACCESS_POINT_DELIVERY","PURCHASE_ORDER","PRODUCTION_CODE","REASON_FOR_EXPORT","SALE","GIFT","SAMPLE","RETURN","REPAIR","INTERCOMPANY_DATA","ANY","INTERNATIONAL_FORM_TYPE","USER_CREATED_FORM","FULL_INVOICE","ShipmentAPI","_createShipment","ShipmentRequest","createShipment","_cancelShipment","trackingNumber","cancelShipment","_getWaybill","_callee3","_ref$format","format","_args3","_callee3$","_context3","_objectWithoutProperties","_excluded","LabelRecoveryRequest","TrackingNumber","String","LabelSpecification","LabelImageFormat","toUpperCase","getWaybill","STATUS_PICKUP","STATUS_OUT_FOR_DELIVERY","STATUS_IN_TRANSIT","STATUS_EXCEPTION","STATUS_DELIVERED","STATUS_RETURNED","TrackingAPI","_getTrackingDetails","get","getTrackingDetails","getTrackingUrl","AUTH_URL","BASE_URL","API_VERSION","GRANT_TYPE","API","_mix$with","_this","kwargs","authUrl","conf","clientId","clientSecret","grantType","token","transactionSrc","_build","method","_get","_getPrototypeOf","headers","Authorization","_bearerAuth","transId","makeid","build","char","charLen","random","_authCallback","params","getToken","authCallback","_getToken","data","contents","_basicAuth","mime","access_token","_handleResponse2","_callee4","errorMessage","error","_args4","_callee4$","_context4","_getResult","ok","JSON","stringify","_unused","OperationalError","status","_handleResponse","_x5","_getResult2","_callee5","_callee5$","_context5","toLowerCase","startsWith","json","text","blob","_x6","auth","Buffer","from","toString","_load2","_callee6","_callee6$","_context6","load","mix","BaseAPI"],"mappings":"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"}